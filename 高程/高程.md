# 高程

## 进制转换

### 二进制与十进制小数之间的转换

当遇到带有小数点的十进制时,并且想将其转换为二进制,对于其整数部分我们只需用常规的短除法来操作,对于其小数部分,我们将单独处理它.  
首先,写下0.xxx,其中xxx为小数点后的部分,然后我们将这个数字乘以2,取得到的数字的个位数
这个数字便是对应十进制的小数点后第一位,如果这个数字是1,那么我们在下一次操作时将这个一改为0,如果是0,那么保持不变,下一步操作是继续乘以2 ,当取了n个数后所得的数字小数点后都是0了,那么就停止操作,我们便得到了十进制下的小数.  

如果想要将二进制小数转换成为十进制小数,只需和整数部分一样采用加权展开即可.  

### 8进制或十六进制转换为2进制

**要注意当把八进制或十六进制转化为二进制时,转化的过程中间应该严格遵循1位对应3或者4位二进制,在写答句的时候可以省略最前面的0**

### 八进制与十六进制之间的转换

八进制与十六进制转换时以2进制为过渡,要注意从八进制或十六进制转换到2进制是所需遵循的规则.

---

## 程序基本概念

1. 函数是程序的基本单位
2. 函数之间的相互位置不影响程序的正确性,只需影响是否要增加声明
3. 函数平行定义,嵌套调用
4. 语句范围为定义语句和执行语句,前者用于声明
5. 应该先去判断一个数是什么类型再去判断它的值
6. 不同编译器的数据的长度可能不同

---

## 数据类型

### 整型

每种整型都有有符号类和无符号两类
||char|int|short|long|loonglong|
|--|--|--|--|--|--|
|所占字节数|1|4|2|4|8

#### 原码

原码由两部分组成:

1. 最高位(最左)的符号位,用0/1来表示正负号
2. 其他位理解为用进制展开的方式来表示数据的绝对值

有两大缺陷:

1. 正负零的二义性
2. 含负数时无法正常运算

**因此计算机内部根本没有原码**

#### 补码

**补码是计算机内部用于存储和表示整数的唯一方式**

其表示正数时的规则与原码一致
表示负数的规则为:绝对值的原码取反+1

#### 关于原码和补码的进一步讨论


取反就是0，1互换  
~~原码换算为补码的逆运算是-1，取反,再变为相反数~~


以2字节-32768为例，先将其转换为其绝对值的二进制1后面在跟15个0,此时最前面的1代表着$2^{15}$也就是10进制里的32768,取反得到0后跟15个1,加一便得到1后面跟15个0,也就是原码中的-0  

要注意的时上面这个案例是极端的,在正数的原码中,第一位永远是0,而在负数的绝对值所对应的二进制中只有像上面的例子那样的极端情况才会在第一位出现1,只有此时绝对值的二进制和其原码不对应,是个特例,其他的时候绝对值的二进制表示和其原码都一样

|原码|补码|
|--|--|
|-0|-32768|
|-1|-32767|
|...|...|
|-32767|-1|

负数的原码加补码等于-32768 即$-2^{15}$
补码通过将正负0的补码统一成全都是0来消除0的二义性,也就是说它把原先的负0给消除了,这使得补码可以比原码多表示一个数,那就是-32768  

#### 进制表示方式

1. 十进制: 正常方式
2. 二进制: 0b+0/1
3. 八进制: 0+0-7
4. 十六进制: 0x/0X+0-F/f

**输出缺省为十进制,可加前导进制转换**

#### 常量后缀

1. 缺省为int型
2. long型后缀加L
3. unsigned型后缀加U
4. short型无对应后缀
5. 后缀顺序没有规定
6. 可用typeid(数据).name()输出数据类型

#### 整型变量相互赋值

**c++中数据溢出不会报错,但是有效数据被截去会报warning**
遵循如下规则:

1. 由短到长:低位赋值,
   1. 短为有符号型:高位补充符号位
   2. 短为无符号型:高位填充0
2. 由长到短:低位赋值,高位丢弃

数据的溢出可以理解为65536进制(2字节)
以一字节signed char为例
|...|0111 1111|1000 0000|...|1111 1110|1111 1111|0000 0000|0000 0001|
|---|----|----|----|----|----|---|----|
|...|127|-128|...|-2|-1|0|1|
可以看出来二进制补码对应的十进制是一个循环,达到最大值127后的下一位便是最小值-128然后不断上升
当第一位为1时,补码对应的十进制是负数,其对应的数和正数一样位权展开,只不过此时的1和0颠倒且是从-1开始加的,即1111 1111=-1
同时也可以理解为以0000 0000=0为基准,然后位权展开,一直累加到127后下一位从-128开始,因此1111 1111是-1,这样来看的话,第一位在1,0之间变换时,会前进\后退128位,例如从0到-128,无论怎样0一定在这两个位置之间,因此两个位置对应的十进制的绝对值之和是128

对于同长度的signed与unsigned互相赋值时,两者对应的十进制的绝对值之和等于2^总位数,如char的话便是258
可以这样理解
|二进制|0000 0000|0000 0001|...|0111 1111|1000 0000|1000 0001|...|1111 1111|
|---|---|---|---|---|---|--|--|---|
|unsigned|0|1|...|127|128|129|...|257|
|signed|0|1|...|127|-128|-127|...|-1|
因此两者在对于首位为1的二进制的处理上发生了差异,在于两者对于128从那里开始不同
|-128|...|-1|0|1|...|127|128|...|257|
|--|--|--|--|--|--|--|--|--|--|
|signed起始处| | | | | | | unsigned起始处 |||
因此两者绝对值之和为258

47页unsign和sign的绝对值相加为65536,快速计算

|输出\输入|unsigned 短|signed 短|
|--|--|--|
|unsigned长|无影响|负数会改变|
|signed长|无影响|无影响|

#### char型

##### ASCII码

应记住的ASCII码

1. 0 - 48
2. 空格 - 32
3. A - 65
4. a - 97

##### 转义符

转义符有以下几种形式

1. '\ASCII码',其中ASCII码需为八进制或十六进制:
   1. 使用八进制时其对应十进制数值范围是0-255,不用加前导进制标识
   2. 使用十六进制时其对应十进制数值范围为0-255,要在最前面加**小写x**,后面a-f大小写不限

**'\0'与'0'不同,前者是ASCII码为0对应的字符,后者则是数字0那个字符**

##### 非法字符

所谓的非法输出是指输出结果并不可信,字体,大小,控制台等等条件都肯能改变非法输出的内容

### 字符串

c和c++中单引号和双引号有严格区别,一个是字符一个是字符串
\是转义符,\+一个字符将它转换为另外一个字符,也就是\+一个字符在内存中是另外一个字符,\不会出现在内存中
字符串的尾0的\0就是被转义到了另外一个字符,因此字符串在内存中的实际字符会多一个

#### 长度计算

字符串长度在计算时不计尾零
strlen只能输入字符串而不能输入字符char,输出的是字符串中字符的个数,不包括尾零,而sizeof既可以输入字符也可以输入字符串,输出的是输入在内存中的字节,因此在输入字符串时会将尾零算入

- 转义符\x后的所有合法的连续十六进制数都会被转义,如果超出255就报错
- 转义符\后最多只会转义连续的3个八进制数
- 如果转义的数字超出255则报错

### 浮点型

#### 内部存储方式

详见后续对IEEE754的讨论.
float型占4个字节,后缀为F
double型占8个字节
缺省为double型

#### 常量表示方法

1. 小数点法:0.12
2. 科学计数法:-1.23e-4
   1. e前必须有数
   2. e后必须为整数

### auto型

auto类型在目前cpp版本中代表自动存储类型,编译器会自动判断其类型

---

## 变量

### 变量命名规则

1. 由字母或下划线开头,由字母,数字,下划线组成,因此不含@-&等符号
2. 不区分大小写
3. 不能与关键字同名
4. 标识符长度意味着只会截取前面多少位字符,如果长度限制是2,那么对于abc和abd,两个都是合法的,但是计算机只会取前面两位即ab

### 变量初始化

变量初始化时赋初值实际上是定义变量和给变量赋值两步.
因此由于优先级,在定义变量时,每一个逗号后或类型后的变量会被定义,后续的表达式都是在给这个变量赋值,从而一个逗号表达式中只有一个变量被定义;
因此

``` cpp
int a=b=c=10;
```

是错误的,因为只有a被定义;
而

```cpp
int c,b,a=b=c=10;
```

是正确的,a是被赋值表达式的值给赋值

### 各类变量之间的比较

|名称|局部变量(自动变量)/形参|外部全局变量|寄存器变量|
|--|--|--|--|
|定义方式|函数内部定义/复合语句内定义(加static变为静态局部变量)|函数体外定义(加static变为静态全局变量)|加前缀register,仅对局部变量有效|
|可访问范围|本函数内(不包括本函数中调用的函数)/该复合语句内|从定义处到源文件结束(其他区域需添加extern声明)(extern对静态全局变量无效)|本函数内|
|存储类型|动态存储区(静态局部变量在静态存储区)|静态存储区|寄存器|
|生存周期|本函数调用期间(静态局部变量赋初值后直至程序结束)|一直存在|本函数调用期间|
|赋值|每次调用均赋值(静态局部变量只在第一次调用时赋初值,默认为0)|默认为0|每次调用均赋值|

**当两变量可访问范围不可能有重叠时可同名**
**当两变量合法同名时,按照底层屏蔽高层的原则处理**

#### 全局作用域符 `::`

1. 为优先级最高的运算符,可用于强制访问高层的同名函数/变量,而不是依照底层屏蔽高层的原则.
2. 使用方法为:
   1. 直接添加`::`表示访问全局级别的同名函数/变量
   2. 添加`函数名::`表示访问该函数名对应的函数中的同名变量

### 外部全局变量的声明

**声明并不会分配空间,只负责说明对于关系**

|声明位置|函数外部|函数内部|
|--|--|--|
|有效区域|所有之后的函数|本函数内部之后的部分|

---

### 符号常量

>可以理解为定义缩写
本质上就是定义了标识符a来代替某一字符串
\#define a b;
上面这行实际上就是把其下面的代码中的a全都换为了b;
本质就是文字替换
>

*整数相除\是直接舍去小数,整除%结果用竖式除法来解决*

## 常变量与符号常量

### 常变量

1. 定义方式为在数据类型前或后增加const字样,其在程序执行时值不变.
2. 在今天存储区内存储

## 运算表达式

### 栈的运算

加入栈的运算符应该是在之前的栈顶运算符之前或者同时生效的运算符,即和它等级相同且右结合(从右往左)或者比它运算等级高,若是之后生效的,即等级更低或者左结合(从左往右)则先对栈顶元素进行运算

a
B  \\
对于这种与顺序相关的运算,正确的应该是B\A,即从下往上取,从左往右列

### 整数相除

**整数除的结果是直接舍去小数,而非四舍五入**

### 类型转换

short a=1 ,b=a+1得到的b是short(先定义,再将表达式赋值,**赋值时以左值类型为准**)
而short a=1,b=1,a+b是int
**参与算术运算的最小数据类型是int,更小的数据类型在参与运算时会自动转为int**
同类型的无符号型比有符号型的转换优先级更高
**类型转换是按需转换,只有在必要的时候才会进行**
float型转换为char\short\int等整数特有的类型时会忽视掉其小数,溢出的处理方法和长变短字节的处理相同,即直接切掉前面的

- [ ] 其他类型准换到float以及float支持的范围,搜索资料

**强制转换对于原变量的类型并不会造成改变,其结果存放在一个临时变量里**

### 自增与自减

当自增与自减位于前面作为前缀时,会直接将其后面的变量加一\减一,作为后缀时,vs会先将原值赋值到一个中间变量中,以它来代替原先的变量来接受其他运算,之后在把原变量加一,而dev则是相反,先将原变量加一,在将加一\减一之前的变量复制到中间变量来进行后续运算,区别在于前者的加一减一操作是在最后执行,而后者不是,从而有可能被后续操作覆盖
前缀效率更高,因为不会创建中间变量
**不能对常量自增自减**

### 取模%

涉及负数时一律转为正数,最后余数的正负在均为正时取的余数的基础上加正负号使得其与被除数的正负一致

### 运算符优先级

需要记忆的运算符中只有两类是右结合

| 优先级 | 结合性 | 类型及代表运算符 |   所有运算符 | 说明|
|--|--|--|--|--|
| 1| | 作用域运算符::|:: | 只有一个|
|2|左结合|->取元素的运算符|->/./[]/()/后缀自增自减|后缀在将自增自减的值的右边,那么肯定是要左结合|
|3|右结合|前缀自增自减|前缀自增自减/!/&/sizeof|前缀加在将要自增自减的元素左边,那么肯定是要右结合|
|5|左结合|*乘法|乘法,除法,取余||
|6|左结合|+|加法,减法|符合正常顺序,结合性以左结合为主,因此这种常见的运算符基本上是左结合的|
|7|左结合|<<|左移和右移|因此在输出语句中进行运算时有时需要在表达式两侧增加括号|
|8|左结合|>|小于,大于,小于等于,大于等于||
|9|左结合|==|等于,不等于||
|13|左结合||&&和||
|14|左结合||或||
|15|右结合||:?||
|16|右结合|赋值|=/*=//=/+=/-=/...||
|18|左结合||逗号运算符||

## 赋值表达式

```cpp
(a=3*5)=4*3;
```

虽然第二个=左边是一个赋值表达式,而不是变量,但是先计算该表达式,使得=时栈中左值为变量a为变量

而

```cpp
a=3*5=4*3;
```

则会报=左v操作数必须为左值的错

## 逗号表达式

逗号表达式的值是有逗号连接的最后一个表达式的值.因为逗号是最低优先级的运算符且为左结合性,依次会依次执行由逗号分隔开来的各个表达式.
表达式1前的逗号会在表达式1后的逗号进栈时消失.因此在逗号表达式的最后栈中只剩下最后一个表达式的值和倒数第二个表达式的值以及一个逗号,该逗号会返回最后一个表达式的值.

## IEEE754

IEEE754标准下所能表示的浮点数$v$的二进制形式形如 $$
(-1)^s2^E(b_0.b_1b_2\dots b_{23})$$
其在内存中占4字节,即32位,可分为三段

1. 符号位:第1位(从左往右,下同),其值记为s,只可能为0或1.为0时尾数为正,为1时尾数为负
2. 指数:第2-9位,其十进制值记为e,范围为0-255减去偏置值127后得到的数记为E,范围为-127-128,从而指数有了正负之分
3. 尾数:第10-32位,记为$f,f=b_1b_2\dots b_{23}$

特殊情况以及$b_0$由以下条件决定:

1. e=255且$f\ne0$时,该$v$表示NaN(Not a number)
2. e=255且f=0,则$v=(-1)^s\infty$
3. 若$0<e<255$,则$b_0=1,v=(-1)^s2^E(b_0.b_1b_2\dots b_{23})$(二进制),称为规格数
4. 若$e=0$且$f\ne0$时,则$b_0=0,v=(-1)^s2^{-126}(b_0.b_1b_2\dots b_{23})$(二进制),称为非规格数
5. 若e=0且f=0,则$v=(-1)^s0$

因此想要得到float型的最大值,应令$s=0,e=254,b_i=1,1\le i\le23$,得到值为
$$
2^{127}(0b1.11111111111111111111111)\approx3.4\times10^{38}
$$
下面探究float型对应的十进制有效位数.  
当我们说有x位有效位数时,即float型能够表示在float型的正最小值到正最大值和负最小值到负最大值这一范围之内的所有有效位数为x的十进制数.
由于对称性,只需考虑$s=0$的情况.

- 规格数

所能表示的十进制数可以分为254个等差数列
|E|首项|公差|末项|首末项之间所能表示的有效位数|
|--|--|--|--|--|
|-126|$2^{-126}\approx 1.2\times10^{-38}$|$2^{-126}\times2^{-23}=2^{-149}\approx1.4\times 10^{-45}$|$2^{-126}\times(2^1-2^{-23})=2^{-125}-2^{-149}\approx2.4\times10^{-38}$|7位(从小数点后44位至小数点后38位)|6位|
|...|...|...|...|...|...|
|0|$2^0=1$|$2^{-23}\approx1.2\times 10^{-7}$|$2^1-2^{-23}\approx2$|7位(从小数点后6位至整数部分第1位)|6位|
|...|...|...|...|...|...|
|10|$2^{10}\approx1.02\times10^{3}$|$2^{10}\times2^{-23}\approx1.2\times10^{-4}$|$2^{10}\times(2^1-2^{-23})\approx2.05\times10^{3}$|7位(从小数点后3位至整数部分第3位)|6-7位|
|...|...|...|...|...|...|
|127|$2^{127}\approx1.7\times10^{38}$|$2^{127}\times2^{-23}=2^{104}\approx2.03\times10^{31}$|$2^{127}\times(2^1-2^{-23})=2^{128}-2^{104}\approx3.4\times10^{38}$|7位(从整数部分第32位至整数部分第38位)|6位|

值得注意的是,这里的有效位数7并不代表float型中就无法存储更多位数的数了,例如$2^{-126}+2^{-149}\approx1.1754944909521339404504436295952\times10^{-38}$,它就可以完整地在float型中储存下来.

理论上浮点数所能表示的有效位数最大值位7位,因为 $$
 n_{理论最大}=\lfloor\lg(2^i-\frac{1}{2}\times2^{i-23})\rfloor-\lfloor\lg2^{i-23}\rfloor\le\lfloor\lg(2^i-\frac{1}{2}\times2^{i-23})-(\lg2^{i-23}-1)\rfloor=\lfloor23\lg2+\lg(1-2^{-24})+1\rfloor=7
$$
上式是利用首项和公差来计算有效位数的,一般而言首项与末项的指数相同,但是也有可能末项的指数比首项的指数大1.
由表可知,一般而言,浮点数所能表示的有效位数为7位,但是该标准中,若准备将数A存储进浮点型,实际对应的浮点数所表示的数实际上是数B,距离数A最近且能被浮点型直接表示的数.如果同时有两个符合条件的数B,则取内存中最后一位为0的数,即较小的那个数.

因此,即使理论上可以表示7位有效数字,但是因为这一取整机制,某些数字在存储进浮点型只有6位有效数字被保留,例如1024.001,对应浮点数在内存中的4字节为`0100 0100 1000 0000 0000 0000 0000 1000`,其对应的十进制为1024.000977,即只有6位有效数字被保留了下来.  

而对于1024.003,对应浮点数在内存中的4字节为`0100 0100 1000 0000 0000 0000 0001 1001`,对应十进制为1024.003052,即7位有效数字被保留了下来.

---

IEEE754标准下所能表示的double型数据$v$的二进制形式形如 $$
(-1)^s2^E(b_0.b_1b_2\dots b_{52})$$
其在内存中占8字节,即64位,可分为三段

1. 符号位:第1位(从左往右,下同),其值记为s,只可能为0或1.为0时尾数为正,为1时尾数为负
2. 指数:第2-12位,其十进制值记为e,范围为0-2047减去偏置值1023后得到的数记为E,范围为-1023-1024,从而指数有了正负之分
3. 尾数:第13-64位,记为$f,f=b_1b_2\dots b_{52}$

特殊情况以及$b_0$由以下条件决定:

1. e=2047且$f\ne0$时,该$v$表示NaN(Not a number)
2. e=2047且f=0,则$v=(-1)^s\infty$
3. 若$0<e<2047$,则$b_0=1,v=(-1)^s2^E(b_0.b_1b_2\dots b_{52})$(二进制),称为规格数
4. 若$e=0$且$f\ne0$时,则$b_0=0,v=(-1)^s2^{-1022}(b_0.b_1b_2\dots b_{52})$(二进制),称为非规格数
5. 若e=0且f=0,则$v=(-1)^s0$

因此想要得到float型的最大值,应令$s=0,e=2046,b_i=1,1\le i\le52$,得到值为
$$
2^{2046}(0b1.1111111111111111111111111111111111111111111111111111)\approx1.7977\times10^{308}
$$
下面探究double型对应的十进制有效位数.  
由于对称性,只需考虑$s=0$的情况.

- 规格数

所能表示的十进制数可以分为2046个等差数列

|E|首项|公差|末项|首末项之间所能表示的有效位数|
|--|--|--|--|--|
|-1022|$2^{-1022}\approx 2.2\times10^{-308}$|$2^{-1022}\times2^{-52}=2^{-1074}\approx4.9\times 10^{-324}$|$2^{-1022}\times(2^1-2^{-52})=2^{-1021}-2^{-1074}\approx4.5\times10^{-308}$|16位(从小数点后323位至小数点后308位)|
|...|...|...|...|...|
|0|$2^0=1$|$2^{-52}\approx2.2\times 10^{-16}$|$2^1-2^{-52}\approx2$|16位(从小数点后15位至整数部分第1位)|
|...|...|...|...|...|
|1023|$2^{1023}\approx8.99\times10^{307}$|$2^{1023}\times2^{-52}=2^{971}\approx1.996\times10^{292}$|$2^{1023}\times(2^1-2^{-52})=2^{1024}-2^{971}\approx1.8\times10^{308}$|15位(从整数部分第293位至整数部分第307位)|

理论上浮点数所能表示的有效位数最大值位16位,因为 $$
n_{理论最大}=\lfloor\lg(2^i-\frac{1}{2}\times2^{i-52})\rfloor-\lfloor\lg2^{i-52}\rfloor\le\lfloor\lg(2^i-\frac{1}{2}\times2^{i-52})-(\lg2^{i-52}-1)\rfloor=\lfloor52\lg2+\lg(1-2^{-54})+1\rfloor=16
$$
上式是利用首项和公差来计算有效位数的,一般而言首项与末项的指数相同,但是也有可能末项的指数比首项的指数大1.
由表可知,double型数据所能表示的有效位数也可能为15位,例如1.234567890123456e307,对应double型数据在内存中的8字节为`0111 1111 1011 0001 1001 0100 1011 0001 0100 1011 1110 0010 0111 1001 1110 0001`,其对应的十进制为1.2345678901234559417535490591099e+307,即只有15位有效数字被保留了下来.

而对于1.234567890123456,对应浮点数在内存中的8字节为`0011 1111 1111 0011 1100 0000 1100 1010 0100 0010 1000 1100 0101 1001 1111 1000`,对应十进制为`1.234567890123456`,即16位有效数字被保留了下来.

---

## 结构化程序设计基础

### 算法

1. 广义定义:为解决某个特定问题而采用的具体的方法和步骤
2. 计算机的定义:对特定问题求解步骤的一种描述,是指令的有限序列,每个指令包含一个或几个基本操作
3. 可以无输入,但必须有输出,可以有多个输入或多个输出
4. 具有确定性,有穷性和有效性

### 程序

#### 基本概念

1. 程序指的是在可以在计算机执行的一组相关的指令及数据的集合,用来完成某一特定的任务及功能
2. 程序由以下两部分组成
   1. 对数据的描述--数据结构(静态)
   2. 操作的描述--算法(动态)
3. 操作的对象是数据
4. 程序-数据的描述+操作的描述=数据结构+算法
5. 程序的基本结构:
   1. 顺序结构
   2. 选择结构
   3. 循环结构
6. 程序基本结构的特点:
   1. 只有一个入口和一个出口
   2. 每一部分均可能被执行
   3. 不存在死循环
7. 一个源文件文件由预处理指令,全局声明及若干函数组成
8. 语句分为四种
   1. 声明语句
   2. 执行语句
      1. 控制语句
         1. if-else
         2. switch
         3. break
         4. goto
         5. for
         6. while
         7. do-while
         8. continue
         9. return
      2.  函数和流对象调用语句
      3.  表达式语句:由表达式和;组成
   3. 空语句:单个;
   4. 复合语句:用一对{}组合而成的语句,里面可以由若干上述语句

#### 细节

1. cpp中复制语句不能参与运算,而赋值表达式可以
2. cout是流对象调用而printf是函数调用,两者并不相容
3. 系统会自动根据cin后变量类型的最长原则来读取合理数据

#### 逻辑运算

1. 逻辑变量bool在内存中占一字节
2. 逻辑变量bool在cin时只能输入0/1,输出时按整型处理
3. 逻辑变量bool在在运算时按"非零为真,零为假"的原则进行
4. 可按整型值0/1参与运算
5. **短路逻辑:仅当必须执行下一个逻辑操作运算符才能求解出值时才执行该运算符,否则不执行**
6. 常见等价表达:
   1. a==0等价与!a
   2. a!=0等价于a
7. 闰年判定:
   1. 被4整除,不被100整除或被四整除,又被400整除
   2. 表达式:!(year%4)&&year%100||!(year%%400),真则为闰年

#### 选择结构

1. 整个if多分支语句可以视为一个语句来看待,之间不允许插入任何其他的语句
2. if不一定由else,但else一定要有if
3. 用栈的方式理解{}匹配

#### 条件表达式 表达式1?表达式2:表达式3

1. 表达式1按逻辑值求解,若为真,求解表达式2并使整个表达式的值为表达式3的值;若为假,则求解表达式3并使整个条件表达式的值为表达式3的值
2. 表达式1,2,3的类型可以不同,但2,3类型必须相容.(流对象与函数并不相容)

#### switch语句

1. 其中的表达式可以是任意类型,只需最终取值为整型即可
2. 不能完全替代多重if语句的嵌套

#### 循环结构

1. 当型循环:先判断后执行(可能一次都不执行)
2. 直到型循环:先执行,后判断(至少执行一次)
3. break只会跳出本循环
4. continue语句会结束本次循环,进行下一次是否执行循环的判断
   1. 对于switch语句没用
   2. for语句中出现continue时会跳出语句序列然后依次执行表达式3和表达式2

##### for语句:for(表达式1;表达式2;表达式3){语句序列;}

执行顺序为:

1. 求解表达式1(整个循环中只执行一次)
2. 以逻辑值求解表达式2,若为真则执行循环体,为假则结束循环体的执行
3. 执行完循环体后,求解表达式3,并转至表达式2

**能与while语句互相转换**
*switch中的case满足后会依次运行之后的case,除非遇到break*
swith的语句序列不用加{}
continue会无视switch语句

### 编译器

编译器不会回溯,因此假如少加了一个;,编译器会认为语句没有结束,从而继续跳到下一行,因此因为,没有加;造成的错误要到下一行时编译器才会检查出来,它也只会报下一行.即在;后的一行出错,而不是;应该在的地方

### 头文件

1. 头文件中不能包含全局变量定义,否则会造成重复定义
2. <头文件名>会让编译器在系统目录中寻找,若找不到则报错
3. "头文件名"会让编译器先在当前目录里找,再在系统目录里找,若都找不到则报错

---

## 函数

### main函数

cpp要求main函数的返回值只能是int,且不能缺省不写,但是部分编译器中可以缺省

### 函数的嵌套调用

函数嵌套调用可采用栈的方式来分析

### 函数参数

1. 形式参数:在被调用函数中出现的参数
2. 实际参数:在调用函数时传入的参数
3. 实参和形参分别占用不同的内存空间,名称可以相同,也可以不同
4. 参数的传递参数是单向传值,可以理解为形参=实参,从而形参的改变不影响实参值
5. 实参可以是常量,变量或表达式,但形参只能是变量
6. 形参在使用时分配内存空间,函数运行结束后释放空间
7. 实参与形参类型需一致,否则赋值是会产生高位截断,低位赋值等问题,且当有效值被截去时会产生warning

### 函数的返回值

1. 若return的数据类型与返回类型定义不一致,则以返回类型为准进行数据转换,理解为调用函数返回值=return语句中的值
2. return后的语句无法被执行到
3. 函数中如果有分支或循环语句,要将所有分支和出口用return覆盖,否则会报warning错.是否覆盖应该不应该以分支或循环中的判断条件为依据,直接按编译器思维来判断

### 函数的调用

调用时不能写返回类型和void以及实参的类型

### 函数的声明

|声明位置|函数外部|函数内部|
|--|--|--|
|有效区域|所有之后的函数|本函数内部之后的部分|

### 内部函数与外部函数

#### 内部函数

1. 内部函数仅能在本源程序中调用,定义时在返回类型前加static
2. 不同文件内的内部函数可以同名

#### 外部函数

1. 外部函数可以在所有的源程序中调用
   1. 本源程序中可直接使用
   2. 其他源程序中要添加函数说明,即原函数出函数体以外的部分,函数说明的有效部分与函数声明一致
2. 默认为外部函数
3. 不同程序中的外部函数如果不通过函数说明被其他文件调用的话则可以同名

### 递归

**递归即在函数中调用该函数本身,用于解决递推类问题.但函数的返回值作本函数的参数是嵌套,而不是递归**
在编写递归函数之前要确认:

- 该函数要输出什么
  - 递归函数中递推关系的起始输出项,例如递推数列中的$a_{n_0}$的值以及$n_0$本身
- 递推关系是什么
  - 后续的输出项与之前的输出项有什么递推关系
  - n是如何回退至回推起始条件的
- 在每一层递推中,递推项i的值都不应改变,每一层的i都独自占用一个形参,是相互隔离的

大致的结构为

``` c++
int fun(递推项i)//递推函数中的递推项i遵循底层屏蔽高层的原则,与一开始的回推起始项这个实参是隔离开来的
{
    if(i==回推起始条件){
		return 起始输出项;
    }
    else{
    i以及fun(i-1)进行运算;//fun(i-1)即对于第i-1项的预期输出,这里的i-1不能改为--i,更不能该为i--,
    //前者是因为下一句是输出第i项的预期输出,当--i时确实会将i-1赋给下一个形参,但是同时会改变该层的形参i,导致一句return无法输出预计值,
    //而后者是先将i输入至fun内在进行i-1的操作,从而导致死循环
    return 对于第i项的预期输出;
    }
}
int main()
{
    fun(回推起始项);//给出的是回推起始项对应的预期输出,实参赋值给形参
}
```

该结构的递归函数只返回一个值,并不进行输出输入等操作

``` c++
void fun(递推项i)//递推函数中的递推项i遵循底层屏蔽高层的原则,与一开始的回推起始项这个实参是隔离开来的
{
    if(i==回推起始条件){
		return ;
    }
    else{
    对i进行操作,如运算,输出等,但不能包含fun(i-1);
    fun(i-1)//或者其他能使i回到回推起始条件的语句
	return ;
    }
}
int main()
{
    fun(回推起始项);//给出的是回推起始项对应的预期输出,实参赋值给形参
}
```

而这个结构能够在递归的同时,实现与i相关的语句和函数

### 重载

重载功能允许同一作用域中多个函数同名.调用重载函数时的匹配顺序为:
1. 寻找参数个数和类型完全一致的函数,**该步中忽略强制转换**
2. 通过系统定义的转换寻找匹配函数,指强制转换
3. 通过用户定义的转换寻找匹配函数

**若同一步中有多个同名函数匹配则报错,因此至少同名函数的参数个数和类型不能均完全相同.**
**编译器不会比较同名函数的返回类型**

### 默认参数

在定义函数时可以在形参表中直接赋值,被赋值的形参必须连续的位于形参表的末尾.当传入实参时,将会按照顺序将实参传入形参,未被传入的形参若在定义时以赋初值,则保持初值不变.**因此若调用时前面的参数欲使用缺省值,后面不适用缺省值,则前面的形参也要通过实参传入缺省值**

**重载与默认参数混合使用时要避免二义性,否则会报错,即使可能产生歧义的多种情况实际上等价**

---

## 指针

### 内存地址

内存地址是以字节为单位,

### 指针变量的定义

格式为:数据类型 *变量名

- 例如:int \*p,其中p是指针变量,而不是\*p
- 数据类型称为该指针变量的基类型,作用是指定通过该指针变量间接访问的变量的类型及占用的内存大小
- 指针变量所占内存空间只和系统的地址总线的宽度无关,在debugx86模式下均为4字节
- 若定义指针时未赋初值,则为野指针,内部地址随机,之后对该地址作任意操作都有可能导致错误
- **数组名本质上是一个指针,指向数组的起始地址,即数组名[0],但是数组名不是变量,不能作自增自减这类操作",sizeof数组名得到的数组的总大小,而sizeof*数组名是a[0]的大小**
- 可以声明void型指针,但不能声明void型简单变量,但可以作为函数的形参和返回值

### 指针变量的使用

1. 指针变量名=存储的地址
2. *指针变量名=存储的地址中的值
3. &变量名=该变量的地址
4. **输出char型的地址会直接以字符串形式输出,因此若是普通变量char型会因为没尾零而输出不可信内容**
5. 指针作函数参数时本质上仍是单向传值,只不过在函数内部能通过传入的地址来改变实参值
6. p[i]与*(p+i)等价,都表示访问数组的第i个元素,对应的地址未基类型+sizeoof(基类型)*i,**6[a]这种形式也是被允许的**
7. 指针与整数不能进行乘除运算,两个基类型相同的指针变量不能进行加和乘除运算,两个不同基类型的指针变量不能进行任何算术运算,void型指针变量不能进行相互运算
8. 作为形参时可以写为一维数组形式,例如int p[],也可写为指针形式int *p,本质上都是个指针变量.对应实参既可以写数组名a也可以是指针变量p
9. 函数的返回类型可以为指针,但是不能返回一个自动变量/形参的地址
10. NULL表示不指向任何变量

### 字符串与指针

1. 用字符串来初始化一个指针时该指针指向的时该字符串常量在内存中的串首字符地址
2. 想要输出字符串地址可以使用cout<<hex<<(void*)p<<endl;的形式,避免以字符串方式输出
3. 字符数组整体赋值用strcpy;
4. 字符串常量是无法通过*地址来改变的,会报错

### 引用

基本格式为&a=b,其中a是引用的名称,引用要与等号右边保持类型相同,因此视情况增加*(指针),[](数组)

**鼓励复用函数**


---

## 程序编写细节处理

1. 一个语句一行
2. 变量名不要用中文
3. 不要使用全文替换
4. 推荐使用常变量而不是符号变量
5. 禁用goto语句
6. 单语句时就不用加{}了,避免累赘
7. 要正确缩进,增加可读性 
8. **禁止使用==来判断浮点型是否相等,应该使用绝对值的误差小于一个很小的数来避免浮点数带来的误差**
9. vs中使用sin等数学公式时不需要cmath的头文件,但是如果要使用的话一定要加上去
10. 推荐格式

``` c++
#include <iostream> 
#include <cmath> //数学函数对应头文件，VS可省略 
using namespace std; 
int main() 
{	double a = 0, b = 5.78 * 3.5, c = 2 * sin(2.0);
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;
	return 0;
}
```

---

## 数组

### 数组的定义

- 定义格式为"数据类型 数组名[正整型常量表达式]"
  - **不能用变量来定义大小**
- 数组在内存中占用一连续的空间

#### 数组的初始化

- 可以选择全部初始化/部分初始化,其他其他自动赋零
  - 未初始化时若为静态变量则默认为0(字符数组中即'\0')
- 可以选择设定数组大小或自动设定大小,其大小合法的最小大小
  - 定义数组时只有第一个下标可以缺省
  - N维数组可以理解为一个元素为N-1维数组的一维数组

### 数组的使用

数组的使用只能逐个引用其中元素,不能整体使用,引用时下标可以用常量或变量表达式来表示
若下标超出范围cpp不会报错

#### 作为参数使用

- 作为实参时只需传入数组名即可
- 作为形参时,除了第一个下标以外的下标必须与实参一致,第一个下标可以为任意值

### 字符数组

- cpp中无字符串常量,可用一维字符数组来表示字符串常量
  - 若想作为字符串使用则其中必须包括'\0',否则之间不等价
    - 字符串长度不包括尾零
    - 字符数组长度即数组的大小
  - 字符串中自动包含尾零
    - 用字符串给字符数组赋初值时会自动包含上尾零,在设定数组大小时要考虑到,否则会报warning错
      - 只用一个字符串赋初值时可以省略{}
      - 只能在字符数组定义时用字符串来赋初值

#### 字符数组的使用

输出字符数组名时会从数组的起始地址开始依次输出各字符的值,直到遇到'\0'为止,称为字符串方式输出

### 字符串处理函数

1. strlen(const char s[]);
   - 求字符串长度,不含尾零
2. strcat(char dst[],const char src[]);
   - 将src连接至dst后面,包含尾零
   - dst需要有足够的空间(考虑尾零),否则会报错
3. strncat(char dst[],const char src[],const unsigned int n);
   - 在之间的基础上增加了指定连接长度的参数n,如果超出则连接全部
   - 也要考虑有足够的空间
4. strcpy(char dst[],const char src[]);
   - 用src覆盖dst,要注意空间,复制时包含尾零
5. strncpy(char dst[],const char src[],unsigned int n)
   - 在之前的基础上增加了指定复制的长度
   - **复制时不包含尾零**鼓励复用函数**
   - 若n超出src长度则会产生越界访问等错误
6. strcmp(const char s1[],const char s2[]);
   - 用于比较字符串s1和字符串s2的大小
     - 相等返回0,不相等时若是s1中的ASCII码大则返回1,否则返回-1
     - **直接比较两个数组名本质上是在比较其内存地址的大小,无意义**
7. strncmp(const char s1[],const char s2[],const unsigned int n);
   - 在之前的基础上增加了比较长度的参数

#### 向字符串输出函数

- 格式:sprintf(字符数组,"格式串",输出列表);
- 返回值为输出的字符的个数
- 字符数组要有足够的空间
- 格式串规则同printf
- 可以实现动态调整用于printf的格式串

#### 从字符串中输入函数

- 格式:sscanf(字符数组,"格式串",输入地址表列);
- 返回值是正确输入数据的个数
- 格式串规则同scanf

### 数据输入处理专题

|函数名|返回值类型|单次读入字符数量|回车后光标位置|回显|回车后开始读取|输入后立刻读取|对空格的处理|对回车的处理|
|--|--|--|--|--|--|--|--|--|
|getchar()|ASCII码|一个|回显下一行|原处回显|是|否|光标移至下一行,返回32|光标移至下一行,返回10|
|_getch()|ASCII码|一个|原处|无|否|是|光标不动,返回32|光标不动,返回13|
|_getche()|ASCII码|一个|紧跟回显|原处回显|否|是|输出空格,返回32|光标不动,返回13|
|cin.get()|ASCII码|一个|回显下一行|原处回显|是|否|光标移至下一行,返回32|光标移至下一行,返回10|
|cin.get(存储数组,字符个数n,终止字符(默认为回车))|ASCII码|n-1个(终止字符不返回,保留在缓存区中,尾部会添加尾零)|回显下一行|原处回显|是|否|输出空格,返回32|光标移至下一行,返回10|
|cin.getline(存储数组,字符个数n,终止字符(默认为回车))|ASCII码|n-1个(终止字符不返回,从缓存区中去除,尾部会添加尾零)(会在缓存区留下一个尾零)|回显下一行|原处回显|是|否|输出空格,返回32|光标移至下一行,返回10|
|cin.peek()|ASCII码|一个|回显下一行|原处回显|是|否|光标移至下一行,返回32|光标移至下一行,返回10|

#### 场景1

|场景描述|单次输入个数|回显|输入类型|输入结束条件|输入错误后处理|对空格的处理|对回车的处理|
|--|--|--|--|--|--|--|--|
||1|原处回显|int型|回车|若输入类型错误则清除缓存区|不视为输入|

代码
使用cin输入
```cpp
	cout << "提示句" << endl;
	while (1) {
		cin >> src;
		if ((输入要求) && !cin.rdstate()) 
			break;//输入完成,跳出循环
		else if (cin.rdstate()) {
			cin.clear();
			cin.ignore(10000000, '\n');//输入错误,清除缓存区
		}
		cout << "提示句" << endl;
	}
	//对输入进行额外处理
```

#### 场景2

|场景描述|单次输入个数|回显|输入类型|输入结束条件|输入错误后处理|对空格的处理|对回车的处理|
|--|--|--|--|--|--|--|--|
|除了回车外其他的控制字符均不生效|多个|原处回显|char型|回车|若输入错误则清除缓存区|不生效|

### string类

- cpp专属方法
- 长度无限制
- 复制可直接用字符串来
- 用赋值运算符来直接在两个string之间复制
- 用"+="实现连接操作
- 直接用比较运算符来进行比较操作

## 结构体

### 结构体类型的定义与结构体变量的定义和初始化

基本格式为

```cpp
struct 结构体名{//结构体名可以省略,这样的话只能在}和;之间声明定义该结构体的变量
   结构体成员1(类型名 成员名)//结构体成员也称为结构体的数据类型
   ...
   结构体成员n(类型名 成员名)//结构体成员的类型不允许是本结构体
   //各成员的作用域,存储方式等由其数据类型决定.
}s1;//有分号,在定义类型的同时定义变量,可用于有名结构体类型与无名结构体类型

struct 结构体名 s2={...};//仅能用于有名结构体类型,初始化时要将所有成员依次列出
```

结构体类型在不同定义时其可使用范围会发生改变

- 函数内部定义:该函数内部可以定义结构体类型的各种变量,并进行成员级访问
- 函数外部定义:
  - 从定义处到本源程序文件结束前均可以定义结构体类型的各种变量,并进行成员级访问
  - 其他位置
    - 若有该结构体类型的重复定义,则可以定义结构体类型的各种变量并进行成员级访问
      - **本质上是不同的结构体,但是运行结果正确,理解时要注意**
      - 常在头文件中进行结构体类型定义
    - 若有该结构体类型的声明`struct 结构体类型名`,则只可以定义该结构体类型的指针,和整体访问,例如传参
  
**类似于外部全局变量概念,但不完全相同**

### 结构体的大小

1. 结构体类型的大小是所有成员大小的总和,**包含填充字节**
   1. 结构体类型,即声明的那一部分不占用内存空间,是结构体变量占据内存空间
   2. 结构体的成员对齐:
      1. 结构体类型的起始地址必须是所有数据类型中占最大字节的**基本数据类型**的整数倍
      2. 所有数据类型的大小总和必须是所有数据类型中占最大字节的基本数据类型的整数倍,若不满足则使用末尾增加填充字节
      3. 结构体类型中各数据成员的起始地址必须是该类型大小的整数倍,若不满足则在末尾增加填充字节
      - 基本数据类型指int,char,float,double.而数组和结构体等不是基本类型,但是仍然要考虑其中的基本类型元素
      - 由于各成员之间可能有字节的填充,在对指向结构体变量成员的指针进行自增(自减)的操作时,只能说指针不再指向原成员,不能说指向下一个(上一个)成员

### 结构体变量的使用

**结构体变量不能进行整体的输入和输出操作**

#### .运算符

使用方法为:结构体变量名.结构体成员
用于访问该结构体变量的成员

#### ->运算符

称为间接成员运算符,使用方法为:指向某结构体变量的指针名->被指向的结构体变量的某成员
用于访问被指向的结构体变量的成员

## 类

1. 类类型在结构体类型的基础上增加了成员函数,其类型定义与变量定义和使用以及内部存储规则上均与结构体类型一致.
2. 不必考虑被内部函数访问的数据成员在内部函数的定义之前定义.
3. **类类型对于的变量常被称为对象**
4. 只能在cpp中使用,c中会报错

### 成员访问限定符`private:`/`public:`

可以用来指定成员是否能被外部函数访问,**对内部函数无效**鼓励复用函数**.
出现的次数和顺序均无限制.
**对于类而言,默认限定符为private,虽然结构体没有限定符,可以视为默认public**

### 成员函数

- 类的成员函数占用函数(代码)区
- 能被外界调用的内部函数称为方法,调用过程称为消息传递
  - 一般将类的数据成员设为私有,通过公有函数来允许外界对数据成员进行操作
  - 将该函数的形参称为提供给外部的访问接口

#### 内部函数体外实现

实现方法为

```cpp
class 类类型名{
   ...
   返回类型 函数名();
   ...
};
返回类型 类类型名 ::  函数名()
{
   ...
}

```

**此时仍被视为内部函数,访问内部成员不受限制**

#### `this`

实际上,为了区分一个类类型的内部函数是在使用哪一个对象的数据成员,内部函数的形参列表中隐藏了一个指向对应对象的指针`this`,函数内部调用数据成员时也是以`this ->`的形式来调用.
**在编写内部函数时不能将`this`指针写在函数声明中,但是可以在内部使用.**

### 类的封装

**通常将类定义写在头文件中,其内部函数在单独的源文件中进行体外实现**

### 对象的初始化

- 若全部数据成员均公有,则可以按照结构体的方式进行初始化
- 若有数据成员为私有,想给它赋初值:
  - 类声明中对其初始化
  - 写一个用于赋初值的共有函数,在使用该数据成员之前调用
  - 定义构造函数

#### 构造函数

可以体内实现也可以体外实现,特别之处在于无需写返回类型和return语句且与对应的对象同名.基本形式为:

```cpp
对象名 (形参表)
{
   ...
}
```

在定义了构造函数后,定义对象的基本方法有以下三种:

```cpp
类类型名 对象名(实参表);
类类型名 对象名{形参表};
类类型名 对象名={实参表};
```

也可以选择在编写构造函数时使用参数初始化表,基本形式为:

```cpp
类类型名 对象名(形参表):成员名1(形参名1),...,成员名n(形参名n)
{
   //可以是空语句或其他语句
}
```

**该方法可用于简单的初始化,无法与条件等语句结合**

- 构造函数会在对象建立时自动调用
- **构造函数必须公有**
- 若不指定一个构造函数则系统缺省生成一个构造函数,形式为无参空体
- 构造函数可以显式调用,可以理解为返回一个被初始化好的对象,常用于带参构造函数\

例如:
```cpp
class Test{
   private:
      int a;
   public:
      Test(int x){
         a=x;
      }
};
Test fun()//这是一个以Test类为返回类型的函数,return语句中的Test(10)返回一个Test类再由fun来返回
{
   ...
   return Test(10);//显式
}
int main()
{
   Test t1(10);//隐式
   Test t2=Test(10);//显示
   Test t3=Test{10};//显式
}
```

不同类型的对象的构造函数的系统自动调用时机不同

- 自动对象(形参):函数中变量定义时
- 静态局部对象:第一次调用时
- 静态全局/外部全局对象:程序开始时 **(main开始前)**

### 析构函数

基本形式为`~类名`,负责在对象被撤销时被自动调用,用于完成内存清理等善后工作.与构造函数一致,无返回值,无需写return语句,必须公有,若没定义系统会缺省生成无参空体;不同的是,它无参且不允许重载,同时还不允许显式调用.

不同类型的对象的析构函数的系统自动调用时机不同

- 自动对象(形参):函数结束时
- 静态局部对象:程序结束时 **(在全局之前)**
- 静态全局/外部全局对象:程序结束时 **(main结束后)**

### 对象数组的初始化

若对象数组对应的对象的构造函数允许只传入一个函数,则可以用一维数组的方式初始化.
若想对单个对象的构造函数传入多个实参,可以使用二维数组的方式来初始化,**此时不能使用()的形式,否则编译器会将其视为一个括号内的逗号表达式,与其中的最后一个表达式等价,从而只能成功传入一个实参**

### 对象的赋值与复制

#### 对象的赋值

对象的赋值的含义为将一个对象的所有数据成员的值对应赋值给另一个**已存在**对象的数据成员,基本形式为`对象名1=对象名2`,**两对象属于同一类,同时由于必须赋值给已存在的对象,因此不能在定义对象1时对其进行赋值**
系统**默认的赋值操作**是将右对象的全部数据成员的值对应赋给左对象的全部数据成员

#### 对象的复制

对象的复制的含义是建立一个新对象,其值与某个已有对象完全相同,基本形式为`类 对象名(已有对象名)`或完全等价的`类 对象名=已有对象名`
系统默认的复制操作是将已有对象的全部数据成员的值对应赋给新对象的全部数据成员

### 友元

某一个类的友元可以访问其private部分,可以被定义为类的友元的成分有:全局函数,其他类的成员函数以及其他类.声明友元的方式是在类的声明中增加友元的声明,以`friend`开头,位置随意.
若成为友元的类被合法引用之前还未被定义,则需要在之前增加该类的声明或者把使用处的`类名`改为`class 类名`即可.

- 被声明为友元的类中的所有成员函数均可以访问对方的私有成员
- 友元是单向而不是双向的
- 友元不具有传递性
- cpp中规定同类的不同对象互为友元