# Database System Concept

## Introduction

### 传统文件处理系统的缺点

传统文件处理系统即将数据存放在操作系统中的文件中。数据库的优点基本上都对应着它的缺点。

### Database

数据库是指一组相互有关联的***数据集合***。

数据库中数据按一定的数据模式进行组织、描述和存储，并支持增删查改，同时支持并发查询处理。

数据库中存有数据页面、索引页面、日志、元数据（数据字典）等信息。

### Database System

数据库系统 = 数据库管理系统（管理数据库的软件，负责查询处理、查询执行、存储管理） + 软件系统
用于管理和操作大量数据
一般包括：

- 数据库
- 数据库管理系统
- 开发工具、应用系统
- 数据库管理员和终端用户

### 数据抽象

三层：

- 物理层：如何存储，对应物理模式/内模式/存储模式
- 逻辑层：数据之间的联系，对应逻辑模式/模式
- 视图层：用户所见，对应外模式/子模式

物理数据独立性：物理模式独立于逻辑模式，修改不受约束
逻辑数据独立性：逻辑模式独立于外模式，修改不受约束

数据模式：数据库的逻辑结构
数据模型：描述数据、数据联系、数据语义及一致性约束的概念工具集合

外模式→模式→内模式之间村子啊映像关系，例如外模式/模式映像、模式/内模式映像 

所用的模型对最终的模式有影响

### 数据字典

包含以下元数据：

- 数据库模式
- 数据存储方法和结构
- 一致性约束和授权

### DML

分为：

1. 过程式DML：指明所需数据和获取方式
2. 声明式DML：指明所需数据但没有具体方式，更易于学习和使用

SQL——Structured Query Language即声明式语言，也即非过程式语言

### 数据库设计

分为三步：

1. 概念设计：决定包含的数据和他们之间的关系，使用E-R模型
2. 逻辑设计：决定数据库模式并将其进行优化
3. 物理设计：决定物理层

### 数据库引擎

分为：

1. 存储管理器：负责数据的存储、检索和更新，处理文件组织、存储访问、索引结构等问题
2. 查询处理器：解析查询语句并执行
3. 事务管理器：由并发管理控制器和恢复管理器组成，用于维护ACID

### 数据库应用系统结构

1. 两层体系结构：应用直连数据库
2. 三层体系结构：采用应用服务器作为中间间，串联起应用和数据库

### DBA 

由以下职责：

1. 模式定义
2. 存储结构和访问方式修改
3. 模式和物理组织方式修改
4. 发放授权
5. 日常维护
6. 明确完整性约束
7. 和用户沟通
8. 监控性能

### 数据库历史

1. 50年代——人工管理
2. 50-60年代——文件系统管理 
3. 60年代至今——数据库管理

## 关系模型

### 关系与关系模式

关系模式相当于变量声明，确定了关系中包含哪些属性。

关系则是一个元组组成的集合，各个元组中包含的属性与关系模式中声明的一致。

### 数据库模式 

- 将所有数据存储至一张表上有以下缺点：
  - 数据冗余：重复
  - 数据稀疏：有些项就是应该空着的

- 码：
  - 超码
  - 候选码
  - 主码
  - 外码：需要参照其他关系的属性，称为外码属性，此时，被参照的关系称为被参照关系，外码属性所在的关系称为参照关系

### 关系代数

六个基本操作：

1. 选择
2. 投影
3. 集合并
4. 集合差
5. 笛卡尔积
6. 重命名 

关系代数的结果仍是关系，是一个集合，没有重复元组。

附加操作不改变关系代数的表达能力，只是使得使用起来更加方便。

- 投影：
  - 有广义版本，得到的表格中的数据不一定存在输入表格中
- 笛卡尔积：
  - 若属性名重复，需要重命名
  - 自然连接自动合并重复的列
  - $\theta$连接只是选择与笛卡尔积的复合运算
  - 外连接：用于避免数据损失
- 聚合函数：例如$_{branch\_name}g_{sum(balance)as\ sum\_balance}(account)$

## SQL 

### 数据类型

1. smallint:int的子集
2. numeric(p,d):共p为，其中有d位小数
3. varchar(n):至多n位
4. char(n):n位
5. float(n):至少n位精度
6. interval:时间跨度
7. blob,clob:大对象

### SQL查询语句

***SQL默认允许结果中含有重复元组***，可以使用`select distinct`来要求对结果去重

提供`between`例如`where amount between 0 and 10`

普通join加上`using(c1,c2)`相当于限制了范围的nature join，对于指定的列也有去重效果，但是对于其他列没有。`join on`相当于`join`和`where`，不会自动对列去重。

可以利用外连接产生的空值来判断是否有缺失。

外连接只会补全原先就缺失，或者因为连接条件，例如`natural join`,`using`,`on`而缺失的元组，但不会补全因为`where`缺失的元组。

更名运算`as`既可以用来属性上，也可以用来关系名上。

用`like`关键词对字符串进行匹配，用`%`,`_`分别匹配任意字符串和任意字母。用`\`转义。

用`lower()`,`upper()`转换为小写字符串和大写字符串。

用`order by`排序，`desc`,`asc`指定降序和升序（默认）。

集合运算默认去重，可以通过`union all`,`intersect all`,`except all`来保留。

除了`count(*)`外的所有聚合操作会忽视空值。

`where`先对整个关系中的元组作筛选，剩余的被聚类，然后用`having`对聚类得到的组进行筛选。

嵌套字查询常用于：

1. 测试集合成员资格`in`,`not in`，可以是一个元组是否包含在子查询返回的关系中
2. 集合比较`<comp> some`,`<comp> all`；用`not exist((A) except (B))`来判断$A\subseteq B$；用`unique`来判断是否有重复元组。
3. 确定集合基数

`from (<query>) as <temporary relation name>(<attributes names>)`可以将子查询转变为查询一个临时关系

`with <temporary relation name>(<attributes list>) as <query>`可以用于创建临时关系。

标量查询可以用在`select`子句中。

### SQL修改语句

`delete from <relation name> <query>`

`insert into <relation name> values <tuple/query>`

在`insert`操作中，先将待插入内容确定下来，再执行插入。

`update <relation name> set <attribute> = <expression> <where clause>`

可以使用`case`子句，`case when <pred1> then <res1> else <res0> end`

### 视图

视图以查询语句的形式被保存，调用时进行替换然后执行。

`create view <name> as A`

无括号

若想更新视图，这些视图的创建方法必须十分基础，只来源于一个关系，且不经聚类等处理。

物化视图即将视图的结果存储下来，需要实时更新或不间断地更新。

### 域约束

`create domain hourly_wage numeric(5,2) constraint value_test check(value >= 6.00)`

`create domain hourly_wage numeric(5,2) not null`

类似的有`create type Dollars as numeric(12,2)[final]`但是type声明不能附加约束

### 索引

`create index <name> on <relation-name> (attribute)`

### 外码约束

建立好外码约束后，若想删除、插入或更新相关的关系，需要确保修改后外码约束没被破坏。

解决的方法是级联修改或者设置为空值或默认值。

### 断言

`create assertion <assertion-name> check <predicate>`

每次更新后都会进行判断

### 授权

分为：

1. 对于数据库增删查改的授权
2. 对于修改数据库模式的权力，例如修改索引、修改授权等

`grant <privilege list> on <relation or view name> to <user list> <with grant option>`

`revoke <privilege list> on <relation or view name> from <user list> [restrict|cascage]`

## Relational Database Design Optimization

### 数据库优化目标

1. 避免冗余数据
2. 能够表示出属性之间存在着的关系
3. 有助于检验一致性约束

### 函数依赖

函数依赖实际上就是说一组属性到另一组属性之间存在一个函数关系（两组属性不一定互斥）。这一定义实际上是用于检验的，而并非用于判断的。也就是说，两组属性之间是否存在函数依赖通常是根据现实意义来直接判断出来的。

显然，当自变量对应的属性减少或因变量对应的属性增多时，函数依赖增强了，反之则减弱了。

当函数依赖$\alpha \rightarrow \beta$成立，且$\alpha$无法再缩小时，则称该$\beta$完全依赖于$\alpha$，否则称为部分依赖。

### 分解

一个大关系可以分解为若干个小关系，必要时再将他们连接起来，这些小关系的属性之间不必互斥。

如果采用自然连接后所得的关系和原关系完全相同，则称该分解为无损分解。

对于分解为两个关系的分解，如果得到的两个关系的属性的交集不为空时，该交集为至少为分解得到的一个关系的超码，则这个分解便是无损的。

对于分解为多个关系的分解，采用表格法来判断是否为无损分解。列为各个属性，行为分解得到的各个关系。一开始，将各个空格填上$a_{i,j}$，如果对于某个关系，给定函数依赖集在它上面的子集中的因变量中含有某属性，则将该位置改为$a_j$。然后遍历所给的函数依赖，如果某两行上的自变量对应着的属性相同，则将其因变量对应着的属性上的元素改为相同的，优先改为形如$a_i$的样式。遍历完所有函数依赖后，如果有一行上的元素都形如$a_i$，则说明该分解时无损分解。

### 函数依赖集

有三条公理可以用于从已知函数依赖中推导出新的函数依赖：

1. （自反律）$\beta\subseteq\alpha\Rightarrow\alpha\rightarrow\beta$
2. （增广律）$\alpha\rightarrow\beta\Rightarrow\gamma\alpha\rightarrow\gamma\beta$
3. （传递律）$\alpha\rightarrow\beta,\beta\rightarrow\gamma\Rightarrow\alpha\rightarrow\gamma$

可以证明，这具有Soundness and Completeness.

从一个函数依赖集$F$可以推导出来的所有函数依赖所组成的集合叫做原集合的闭包$F^{+}$。

只需要对于已经得到的函数依赖集中的每个函数依赖依次使用自反律和增广律，然后使用传递率，如此循环，知道无法得到新的函数依赖为止，我们便可以得到闭包。

### 属性集的闭包

对于一个指定的函数依赖集$\mathbf{\alpha}$，一个属性集的闭包$\mathbf{\alpha}^{+}$定义为可以用该函数依赖集推导出来的所有因变量所组成的集合。
\[\alpha\rightarrow\beta\in F^{+}\Leftrightarrow\beta\in\mathbf{\alpha}^{+}\]
想要求出一个属性集的闭包，只需维护一个属性集，其中的属性是可以依据所给$F$（而非$F^{+}$）直接得到的因变量，一开始包含$\mathbf{\alpha}$，随着不断更新而扩大，最终确定下来的集合便是所求的闭包。

### 正则覆盖

对于一个函数依赖集，我们称与之等价的、且无冗余属性和函数依赖的函数依赖集为它的正则覆盖。

对于一个函数依赖$\alpha\rightarrow\beta$，如果我们从$\alpha$中删去一个属性，我们得到的是一个更强的函数依赖，因此我们需要证明这实际上是可以从已知函数依赖集中推导出来的；如果我们删去$\beta$，我们得到的是一个更弱的函数依赖，因此我们需要证明采用这个函数依赖时，仍然可以推导出当前的函数依赖集

想要计算一个函数依赖集的闭包，我们首先需要将形如$\mathbf{\alpha}\rightarrow\mathbf{\beta_i}$的函数依赖合并为$\mathbf{\alpha}\rightarrow\prod_i\mathbf{\beta_i}$，然后验证是否能够进行上述化简，如此往复，知道确定为止，这样得到的集合便是闭包。

### 候选码

给定函数依赖集，和一个关系，可以将该关系中的各个属性按照是否只作为自变量、只作为因变量、既作为自变量又作为因变量、既不作为自变量又不作为因变量划分为4类，分别记为L、R、LR、N，将$L\cup N$记为$X$，如果$X$能够作为超码，那么$X$就是唯一的候选码，否则，遍历$LR$的一元子集，将其和$X$作并后判断是否为超码，如果是则记为一个候选码，将其从$LR$中划去，如果在这一轮中$LR$仍有剩余，则再次继续遍历$LR$的二元子集，以此类推，直到无法继续为止。

### 函数依赖保持

一个分解是函数依赖保持的，即原关系上的函数依赖集在分解得到的各个关系上的子集之并与原函数依赖集等价，即两者的函数依赖闭包相同。

显然，一个充分条件是原函数依赖集中的每个函数依赖至少在分解得到的一个关系上体现出来。

而充分必要条件则是：对于原函数依赖集中的每个函数依赖$\alpha\rightarrow\beta$，依次在每个分解得到的关系上求能够推出的属性，不断循环扩大，直到不变化为止，然后查看是否包含$\beta$。

### 第一范式

每个属性都是原子属性

### 第二范式

每个非码属性都完全依赖于主码

### 第三范式

没有传递依赖，即没有非码属性与非码属性之间的函数依赖

形式化地讲，对于函数依赖集中的每个函数依赖$\alpha\rightarrow\beta$，要么它是平凡的，要么$\alpha$是超码，要么$\beta-\alpha$的每个属性都包含在模式的某个候选码中。

如果模式不满足第三范式，则可以进行分解，得到的模式满足第三范式，且分解是依赖保持且无损的。

分解的方法是先求出模式的正则覆盖，将其中的每个函数依赖的自变量和因变量连接在一起得到新的模式。若这样得到的模式中，没有一个含有原来的模式的候选码，则将一个候选码单独作为模式加入分解得到的模式中。

### BC范式

函数依赖要么是平凡的，要么自变量是超码。

给定一个关系和它上面的函数依赖集，只需要验证给定函数依赖集中的每个非平凡的函数依赖的自变量都是超码即可，无需对给定函数依赖集的函数依赖闭包中的每个函数依赖进行验证。

但是对于分解得到的各个关系，由于之前的函数依赖集在其上的子集并不能推出在其上的所有函数依赖，所以此时不能仅仅判断这些函数依赖便得出分解得到的关系满足BC范式。

为此，一种方法是对于分解得到的每个关系，验证原函数依赖集的函数依赖闭包在其上的子集（即在其上的限制）；另一种方法是，对于分解得到的每一个关系，对于其中的任意属性集$\alpha$，验证其是否是超码或它的属性闭包就是自身，如果不是，则说明不遵循BC范式。

不遵循BC范式的模式可以分解为满足BC范式的模式，且是无损连接，但是不能保证是依赖保持的。

分解的方法是：起始模式为$R$，取一个函数依赖$\alpha\rightarrow\beta$使得$\alpha$不为超码，且$\alpha\cap\beta=\varnothing$，则将$R$改为$R-\beta$，然后将$\alpha\beta$作为分解得到的一个新模式；如此往复，直到$R$满足BC范式。

## B+-树

对于一个B+-树，有一个参数$n$是确定的。

### 结点

|第一个指针域|第一个值域|第二个指针域|$\cdots$|第$i$个指针域|第$i$个值域|第$i+1$个指针域|$\cdots$|第$n-1$个值域|第$n$个指针域|
|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|----------|---------|
|$P_1$|$K_1$|$P_2$|$\cdots$|$P_i$|$K_i$|$P_{i+1}$|$\cdots$|K_{n-1}|$P_n$|
|$<K_1$||$\geq K_1$|$\cdots$|$<K_i$||$\geq K_{i}$|$\cdots$||下一个兄弟结点|

#### 非叶子结点

指针域中存储的是指向结点的指针。

若不是根节点，则需要有$\lceil n/2\rceil$到$n$个孩子，即有$\lceil n/2\rceil$到$n$个非空指针域。

若是根节点，则需要有$2$到$n$个孩子，即有$2$到$n$个非空指针域。

#### 叶子结点

指针域中存储的是指向其右侧值域对应的文件记录（在磁盘中的位置）的指针。结点最右侧的指针指向的是兄弟结点。

要求至少有$\lceil (n-1)/2\rceil$个非空值域。

### 查询操作

#### 单值查询

从根节点出发，要一直下降至对于的叶子结点中，然后载该叶子结点中进行遍历比较。

为了下降到正确的孩子结点中，由于$P_i$，$P_{i+1}$指向的左右两个孩子结点中存储的值以$K_i$作为分界，所以只需要将查询值与$K_i$进行比较即可。从第一个值域开始比较，若小于，则沿左侧的指针下降，否则继续与下一个值域进行比较，查看是否有机会沿右侧指针下降，极端情况是所有值域都小于待查询值，此时将指针设为最右侧的指针域。

下降到叶子结点后，对其进行遍历，若没有找到，则返回空指针。

### 更新操作

#### 插入

当插入一个值时，首先要通过单值查询操作获取到应该插入的叶子结点。如果该叶子没有满，则直接按照顺序插入即可。否则，插入前应该有$n-1$个值域，加上待插入的值，便有$n$个值域，为此，需要分为两个叶子结点，前$\lceil n/2\rceil$个值域留在原来的叶子结点中，后续值域分给新的叶子结点。

此时，需要在原先叶子结点的父结点中增加一个值域和一个指针域（指针域在值域的右侧），分别是新的叶子结点中的第一个值以及指向新的叶子结点的指针。如果不会产生溢出，则直接插入即可。否则，先将新增值域和指针域按照顺序插入。然后进行拆分，将前$\lceil (n+1)/2\rceil$(可以看到，分配给左边的，即保留在原节点的总是大于分配给右边的)个指针域以及夹在其中的值域保留在原结点中，而剩余的指针域以及夹在其中的值域转移到新增的兄弟结点中。此时，仍有一个值域没有被安放，它随同指向新增结点的指针一同插入到原结点的父节点中（指针域在值域的右侧），形成递归。

#### 删除

当删除一个值时，若它是根结点且删除后只有一个孩子，则直接把它的孩子结点作为新的根节点。

否则。如果被删除的叶子结点中的值/指针过少，则尝试和左兄弟结点进行合并。如果可以进行，即左兄弟结点仍有空间，则将它们合并，左兄弟的指向右兄弟的指针替换为右兄弟对应位置的指针，并将如果不是叶结点，还要添加父节点中夹在指向兄弟结点指针中间的值域。此时，还需要删除父结点中夹在指向两兄弟结点的指针中间的值，同时还要删除被合并的结点，即右兄弟结点的指针。此时进行递归，且如果删除操作不是对于叶子结点，则无需更新指向兄弟结点的指针（实际上也不存在）。

如果不可以进行，则说明左兄弟结点已满。因为删除前是满足约束的，意味着只需要增加一项便可以重新满足约束，从而思想是从左兄弟结点中“借”一个值-指针对。只需要直接将左兄弟的最后一对移动到右兄弟的起始就行了，同时还要修改父结点中的一个值域（无需修改指针域），即指向右兄弟结点的指针域对应的值域，需要改为移动的值域。要注意的是，对于叶子结点，最后一个值域-指针域对是倒数第二、三个非空的域，倒数第一个是指向兄弟结点的指针域。而对于非叶子结点而言，便是最后两个非空域。对于非叶子结点，操作复杂一些，左兄弟结点的最后一个值域移动到父结点中的指向兄弟结点的指针中间的值域，而原先在该值域的值和左兄弟结点的最后一个指针域移动到右兄弟结点的开端。

上述操作中，不一定是要选择左兄弟结点来进行调整，原则是要让指向两个兄弟结点的指针在同一父节点中。