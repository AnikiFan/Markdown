# 数据结构设计与算法设计

时间:2023年秋季

本笔记结合数据结构与算法设计的课堂内容以及
*Data structures and Algorithm Analysis in C*.
部分数学基础内容来自于 *Concrete Mathematics*.

## 课程基本信息

### 上课形式

- 课堂
- 机房上机: 星期二晚上,第三周开始

### 课程考核

- 考勤:10%:课堂和上机
- 实验作业:35%(OJ系统,有查重)
- 课堂表现:10%(小测,研讨和平时提问)(可能单周四节连上时最后半节课会有小测)
- 期中考试:15%(大概率闭卷考,也有可能是大作业)
- 期末考试:30%

## 应试

### 线性表 

1. 在一个长度为 $n$的顺序表中插入一个元素的平均复杂度为 $n/2$，删除一个元素的平均复杂度为$(n-1)/2$。删除可以理解为对 长度为 $n-1$的顺序表进行插入。

### 栈和队列

### 串、数组和广义表

1. 一个字符串的`next`数组以-1,0开始，即`next[0]=-1`然后`next[i]`元素即该字符串的前i个字符组成的字串中最长的公共前后缀的长度，如果为回文串，则为`next[i]=0`，这样的理解方式下，最后一个字符没有对应的`next`值，`next`数组的长度等于字符串的长度。标准的理解方式是`next[i]`中存储的是当字符串中`a_i`失配时，下一个进行判断的特征中的位置。`-1`代表待匹配位置后移。本质上还是找前 $i-1$个字符中的最长公共前后缀。
2. 数组元素之间的关系既不是线性的，也不是树形的
3. 注意对角矩阵的左右上下角不是完整的。
4. 空串是指长度为0的串，而空白串是指只由空格组成的串，长度不为0。
5. 字符串不一定有结束符，可以用长度来代替

## 第一章:绪论

### 数学基础

#### 数项级数

\[\sum_{i=1}^N i^k\approx\frac{N^{k+1}}{\lvert k+1\rvert}\phantom{wwwww}k\neq -1\]
\[H_N=\sum^N_{i=1}\frac{1}{i}\approx\log_eN\]

#### 模运算

如果 $a\equiv b(\text{mod} n)$,那么有
\[a+c\equiv b+c(\text{mod} n )\]
\[ad\equiv bd(\text{mod} n )\]

#### 求解递归表达式的封闭形式

##### 求解含有可变参数的递归表达式

对于没有可变参数的递归定义函数, 我们可以先列表计算出前若干项,然后观察规律,
猜测出合理的封闭形式,然后利用数学归纳法证明.

对于含有可变参数的递归定义函数,例如
\[\begin{cases}
R_0=\alpha\\
R_n=R_{n-1}+\beta+\gamma n
\end{cases}\]
如果最终的闭合形式是可变参数的线性组合(有时要靠猜测),例如 $R_n=A(n)\alpha+B(n)\beta+C(n)\gamma$
那么我们可以把一些简单的方程代入递归定义表达式，解出每个方程对应的可变参数。最后把这些参数和对应的方程代入线性组合形成线性方程组。解出线性方程组即可。
方程选取的准则是可以轻松解出参数，方程选取的个数应该要让线性方程组有唯一解。

##### 求解$a_nT_n=b_nT_{n-1}+c_n$形式的递归表达式

整体思想是将该递归表达式的求解转化为对求和形式的求解。为此我们要找到求和因子$s_n$，满足
\[s_nb_n=s_{n-1}a_{n-1}\]
从而
\[s_na_nT_n=s_nb_nT_{n-1}+s_nc_n=s_{n-1}a_{n-1}T_{n-1}+s_nc_n\]
记 $S_n=s_na_nT_n$,则
\[S_n=S_{n-1}+s_nc_n\]
从而有
\[S_n=s_0a_0T_0+\sum^n_{k=1}s_kc_k=s_1b_1T_0+\sum^n_{k=1}s_kc_k\]
所以
\[T_n=\frac{1}{s_na_n}S_n\]
其中 
\[s_n=\frac{a_{n-1}a_{n-2}\cdots a_1}{b_nb_{n-1}\cdots b_2}\]

##### 利用指标替换求解双重求和表达式

如果我们有一个双重求和表达式，被求和的元素中含有 $k+f(j)$，其中 $f$是任意函数，
那么我们可以尝试将 $k$ 替换为 $k-f(j)$，并优先对 $j$ 求和。

例如 
\[
S_n=\sum_{1\leq j<k\leq n}\frac{1}{k-j}=\sum_{1\leq j<k+j\leq n}\frac{1}{k}=\sum_{1\leq k\leq n}\sum_{1\leq j \leq n-k}\frac{1}{k}
\]
在该例中，我们从按行或列求和转化为按照对角线求和，从而简化了求和过程。

#### 求解求和表达式的封闭形式

##### 微扰法

\[\begin{array}{rl}
S_n+a_{n+1}=\sum_{0\leq k\leq n+1}a_k&=a_0+\sum_{1\leq k\leq n+1}a_k\\
                                     &=a_0+\sum_{1\leq k+1\leq n+1}a_{k+1}\\
                                     &=a_0+\sum_{0\leq k\leq n}a_{k+1}\\
\end{array}\]
如果我们能将最后一个求和号转化为关于$S_n$的关系式，那么我们便可以得到关于 $S_n$的关系式，并从中解出$S_n$的封闭形式。

##### 利用微积分求解

我们可以把求和表达式中的参量视为变量，从而把求和表达式视为以那个参量为自变量的函数项级数，从而对其利用积分和微分等操作。

例如，为了求解 $\sum_{k=0}^nx^k$，我们有
\[\sum^{n}_{k=0}x^k=\frac{1-x^{n+1}}{1-x}\]
对其两边对$x$求导可得
\[\sum_{k=0}^nkx^{k-1}=\frac{1-(n+1)x^n+nx^{n+1}}{(1-x)^2}\]
对其等号两边同乘以 $x$，便可得到欲求的封闭形式。

#### 求和记号

##### 交换律

\[\sum_{k\in K}a_k=\sum_{p(k)\in K}a_{p(k)}\]
其中 $p(k)$ 是 $K$ 的一个置换。
如果我们用 $f(j)$来代替 $k$，其中 $f$是任意一个从 $J $到 $K$上的映射，那么
\[\sum_{j\in J}a_{f(j)}=\sum_{k\in K}a_k\#f^-(k)\]
其中 $\#f^-(k)$代表着集合
\[f^-(k)=\{j|f(j)=k\}\]
中的元素个数。

##### 分配律

多重求和的分配律为
\[\sum_{j\in J,k\in K}a_jb_k=(\sum_{j\in J}a_j)(\sum_{k\in K}b_k)\]

##### 结合律

多重求和的结合律的一般形式为
\[\sum_j\sum_ka_{j,k}[P(j,k)]=\sum_{P(j,k)}a_{j,k}=\sum_k\sum_ja_{j,k}[P(j,k)]\]

当内外层的求和指标相互独立时，有化简形式：
\[\sum_{j\in J}\sum_{k\in K}a_{j,k}=\sum_{j\in J,k\in K}a_{j,k}=\sum_{k\in K}\sum_{j\in J}a_{j,k}\]

当内外层的求和指标相互独立时，若要相互交换，即：
\[\sum_{j\in J}\sum_{k\in K(j)}a_{j,k}=\sum_{k\in K'}\sum_{j\in J'(k)}a_{j,k}\]
其中的求和条件需要满足：
\[[j\in J][k\in K(j)]=[k\in K'][j\in J'(k)]\]
特别地，我们有
\[[1\leq j\leq n][j\leq k\leq n]=[1\leq j\leq k\leq n]=[1\leq k\leq n][1\leq j\leq k]\]
即 
\[\sum_{j=1}^n\sum_{k=j}^na_{j,k}=\sum_{1\leq j\leq k\leq n}a_{j,k}=\sum_{k=1}^n\sum_{j=1}^ka_{j,k}\]

##### 有限微积分（FINITE CALCULUS）

在有限微积分中，我们定义差分算法$\Delta$和位移算符$E$分别为
\[Ef(x)=f(x+1)\phantom{111} \Delta f(x)=Ef(x)-f(x)\]
并且定义上下阶乘分别为
\[x^{\underline{m}}=x(x-1)\cdots(x-m+1)\phantom{111}x^{\overline{m}}=x(x+1)\cdots(x+m-1)\]
其中整数$m\geq 0$。$x$的 $m$上下阶乘中均有 $m$个因子。我们规定 $x$的0上下阶乘均为1。
易证
\[\Delta(x^{\underline{m}})=mx^{\underline{m-1}}\]
我们规定
\[g(x)=\Delta f(x)\text{ 当且仅当 }\sum g(x)\delta x=f(x)+C\]
其中 $C$为任意满足 $f(x+1)=f(x)$的函数
类似于微积分基本定理，如果 $g(x)=\Delta f(x)$，则
\[\sum\nolimits_a^bg(x)\delta x=\left.f(x)\right|^b_a=f(b)-f(a).\]
其中 
\[\sum\nolimits^b_ag(x)\delta x=\sum_{k=a}^{b-1}g(k)=\sum_{a\leq k<b}g(k),\phantom{111}b\geq a\]
和积分符号类似地，我们有$\sum_a^b=-\sum_b^a,\sum_a^b+\sum_b^c=\sum_a^c$。
我们进一步定义
\[x^{\underline{-m}}=\frac{1}{(x+1)(x+2)\cdots(x+m)},\phantom{111}x>0\]
可以验证，我们有
\[x^{\underline{m+n}}=x^{\underline{m}}(x-m)^{\underline{n}}\]
在有限微积分中，我们用下阶乘来类比次幂，我们还用调和级数来类比自然对数：
\[
  \sum\nolimits_a^bx^{\underline{x}}\delta x=
  \begin{cases}
  \left.\frac{x^{\underline{m+1}}}{m+1}\right|^b_a,&\text{当}m\neq -1;\\
  \left.H_x\right|^b_a,&\text{当}m=-1.\\
  \end{cases}
  \]
并用$2^x$来类比 $e^x$：
\[\Delta(c^x)=(c-1)c^x\phantom{111}\sum_{a\leq k<b}c^k=\sum\nolimits_a^bc^x\delta x=\left.\frac{c^x}{c-1}\right|^b_a=\frac{c^b-c^a}{c-1},\phantom{111}\text{当}c\neq 1\]
在有限微积分中，并不存在链式法则，变量替换也较为困难，但是仍然存在分部积分的类比：
\[\Delta(uv)=u\Delta v+Ev\Delta u\]
\[\sum u\Delta v=uv-\sum Ev\Delta u\]

有限微积分十分强大，给我们提供了系统性求解求和表达式的工具
例如：
\[
  \begin{array}{rl}
    \sum xH_x\delta x&=\frac{x^{\underline{2}}}{2}H_x-\sum\frac{(x+1)^{\underline{2}}}{2}x^{\underline{-1}}\delta x\\
    &=\frac{x^{\underline{2}}}{2}H_x-\frac{1}{2}\sum x^{\underline{1}}\delta x\\
    &=\frac{x^{\underline{2}}}{2}H_x-\frac{x^{\underline{2}}}{4}+C\\
  \end{array}
  \]
  因此我们有
  \[\sum_{0\leq k<n}kH_k=\sum\nolimits^n_0xH_x\delta x=\frac{n^{\underline{2}}}{2}(H_n-\frac{1}{2}).\]

#### 渐进表达式

若当n足够大时存在常数c使得
\[T(n)\leq cf(n),\]
我们记
\[T(n)=O(f(n))\]

### 递归函数设计要素

1. 要设置初始条件
2. 每一次递归后都要向初始条件靠近
3. 设计时将所有使用的更底层的递归视为能正确工作
4. *Compound interest rule.* Never duplicate work by solving the same instance of a problem in separate recursive calls.这也是为什么不推荐用递归函数来求解简单数学函数,如斐波那契数列,的值的原因.

### 算法分析

在估算时间复杂度时,不要忘了条件语句中的判断,以及for语句中每次循环的增量语句.

总体有五条法则:

1. 对于循环而言,其复杂度最多是其内部语句的复杂度乘以循环次数
2. 对于嵌套循环而言,其语句是循环语句乘以所有循环的循环次数.
3. 对于顺序语句:抓住重点,整体的复杂度取决于最复杂的语句.
4. 对于条件语句:其复杂度不超过判断语句加上第一复杂的分支语句的复杂度
5. 从内层向外层进行分析,如果有函数调用,则先分析函数

### ADT 设计要点

1. 要使用sizeof来确定类型大小,因为即使是同一类型,在不同的环境中也有可能有不同的大小.
2. 在定义操作时要在程序中检查传入参数的合法性,例如检查下标是否超出范围,是否内存溢出等等.
3. 顺序表等类型在插入元素时从列表的最后一位开始向后平移,如果从被插入处开始平移的话,则需要中间变量来存储被覆盖的数据.
4. 不再使用的内存空间要即使释放。

## 第二章:基本概念

### 数据结构

数据结构时相互之间存在一种或多种关系的数据元素的集合,这种数据元素之间的关系加上数据元素本身便是所谓的结构.
其形式定义为二元组(D,S),其中D是数据元素的有限集,S是D上关系的有限集.

D 中若是有序数对,例如线性结构,树型结构,则用<>来表示,若为无序数对,则用()来表示.

数据即能够输入到计算机中并被处理的符号的集合.
数据元素是数据的基本单位,常被视为一个整体来处理.
数据项则是数据的不可分割的最小单位
数据对象则是性质相同的数据元素的集合,是数据的一个子集.

数据结构可以按照其逻辑结构和物理结构以及允许的操作来进行分类

#### 逻辑结构

四种基本逻辑结构为:

1. 集合:元素仅属于同一个集体,没有其他关系
2. 线性结构:存在一对一关系(如每个元素对应其后继),序列相邻,并有次序关系
3. 树型结构:存在一对多关系以及层次关系
4. 图状结构:存在多对多关系,具有任意性

#### 物理结构(存储结构)

我们把存储器建模为一系列固定大小的存储单元,每个单元有一个唯一的地址,该地址被连续编码.
同时每个单元有唯一的后继单元.

物理结构便是逻辑结构到存储器的一个映射,分为:

1. 顺序存储:利用元素在存储器中的相对位置来表示之间的逻辑关系
2. 链接存储:利用指针
3. 索引存储:存储节点外还建立索引表,其每一项称为索引项,形式为:关键字,地址
4. 散列存储:根据节点的关键字直接计算出该节点的存储地址

#### 数据结构允许的操作 

1. 静态结构--操作后,数据的结构特性不变,例如数组
2. 半静态结构--操作后,数据的结构特性轻微改变,如栈,队列
3. 动态结构--操作后变换灵活,可随意重新组织结构,如指针.

### 抽象数据类型-ADT

ADT是指基于一个逻辑类型的数据模型以及定义在该模型上的一组操作。每一个操作由它的输入和输出定义。
其形式定义为三元组(D,S,P),S是D上关系的有限集,P是对D的基本操作集.

ADT的定义不涉及具体实现,即是被封装了的.数据结构则是其物理实现.

抽象数据类型与数据类型实际上是同一个概念

### 算法与算法分析

#### 算法的定义

算法是指一系列确定的并且是在有限步骤内能完成的操作.
算法具有有穷性,确定性,可以没输入,但必须有输出,同时具有可行性.

程序不具有有穷性,因此不是算法.

#### 算法设计

算法和数据结构是相互依赖的.

一个好的算法首先要正确,同时要具有可读性,并且有一定的容错性以及时间和空间上的效率,即能
在有限的时空资源内将问题解决.

## 线性表 

### 线性结构

线性结构即一个满足以下条件的数据元素的非空有限集:

1. 有一个开始节点
2. 有一个终端节点 
3. 其他节点有且仅有一个前驱和一个后继 

### 线性序列

线性序列则是线性结构中所有节点按其排序排成的一个序列,记为 
\[(a_1,\cdots,a_i,a_{i+1},\cdots,a_n)\]

### 线性表的类型定义

线性表是一个有限序列 ,是最常用最简单的数据结构.
数据结构描述为:
\[List=(D,R)\]
\[其中D=\{a_i|a_i\in D_0,i=1,2,\cdots,n,n\geq 0\},R=\{R\},N=\{<a_{i-1},a_i>|a_{i-1},a_i\in D_0,i=2,3,\cdots,n\}\]
$D_0$为某个数据对象.

线性表具有均匀性和有序性

线性表中的元素下标从1开始,元素的下标称为该元素在线性表中的位序.线性表支持增加和删除元素,

### 线性表的存储结构

#### 顺序表

定义为在计算机内存中用一组地址连续的存储单元依次存储线性表中的各个数据元素.

即用物理位置的相邻以及前后关系来表示数据元素之间的(线性)逻辑关系.

优势有:

1. 随机存储结构:如果每个元素占用的存储单位固定,只需要知道顺序表的起始位置(或称为基地址)以及元素的位序,便可以直接算出该元素所在位置.
2. 存储效率高,是紧凑结构
3. 结构简单

缺点有:

1. 进行插入和删除操作时,需要移动数据元素,算法效率较低
2. 对于长度变化较大的线性表,或者要预先分配较大空间或者要经常扩充线性表,给操作带来不方便.
   - 原因在于数组的静态特性
   - 插入元素时,若长度超过分配长度，则要重新分配空间(`realloc`),而非在原来的基础上直接扩展

#### 链表

定义为在内存中用一组任意的存储单元来存储线性表的数据元素，用每个数据元素所带的指针来确定其后继元素的存储位置。这两部分信息组成数据元素的存储映像，称作结点。

即每个结点由数据域与指针域(链域),n个结点链接成一个链表.

##### 单链表

单链表也称线性链表,即一个每个结点只包含一个指针域的链表.

- 头指针:指向链表中的第一个节点(可能是头结点,也可能时开始结点)
- 开始结点:第一个数据元素结点
- 头结点:有时会在单链表的第一个元素节点之前附设一个节点,称为头结点
  - 其next域指向链表中的第一个数据元素结点
  - 其数据域可以作一下处理:
    - 加特殊信息
    - 置空
    - 如数据域为整型,则在该处存放链表长度信息.
  - 优势有:
    - 开始结点的位置也被存放在另一个结点(头结点)的指针域中,因此无需对其作特殊处理
    - 无论链表是否为空,其头指针是指向头结点的非空指针,使得对空表和非空表处理统一起来
    - 判断链表是否为空可以用`if(L->next)`来判断,其中`L`为头指针
  - 因此常常使用含有头结点的链表

###### 结点的删除

要删除一个节点时,一定要先用一个变量来保存删除节点的指针域,否则其后面的链表会丢失.

同时,最后要用`free(p)`来释放被删除的结点所占用的空间.

##### 循环链表

循环链表即首尾相接的链表。其最后一个节点的指针域不为`NULL`。循环条件为`p->next != H`，其中 `H`为头指针。
为了简化操作，常常在循环链表中加入表头节点。

##### 双向链表

双向链表即在前驱和后继方向都能遍历的线性链表。双向链表通常采用带表结点的循环链表形式。
显然，在一个双向链表中有`p == p->prior->next==p->next->prior`。特别地，对于空表，`p->prior == p==p->next`
在删除一个结点前，一定要有一个工作指针指向它，为了之后便于释放该位置。
创建双链表时，L是一个指针，因为要改变L中的值，例如分配给它空间，所以要用`&L`，即引用来传参。

##### 不同形式的链表间的比较

|单链表|循环链表|
|--|--|
|必须从头指针开始遍历|可以从任一结点出发开始遍历|
|表尾指针的指针域为`NULL`|表尾节点的指针域是指向链表头节点的指针`H`，没有指针域为`NULL`的结点|

##### 线性链表可改进的地方

用上述定义的单链表实现线性表的操作存在如下问题：

1. 单链表的表长是个隐含的值
2. 在单链表的末尾插入元素时，需要遍历整个链表
3. 在链表中，元素的“位序”概念淡化，结点的位置概念强化

对此，我们可以：

1. 增加“表长”，“表尾指针”，“当前位置指针”三个数据域；
2. 将基本操作由“位序”改变为“指针”

#### 不同存储结构之间的比较

||顺序表|链表|
|--|--|--|
|空间利用率|存储空间是静态分配的，在执行那个程序前预先分配一定长度的连续的存储空间，可能导致存储空间的浪费或溢出|存储空间动态分配，且无需连续，除非超级极端情况，否则不会发生溢出。但指针域需额外占用存储空间|
|时间效率|适用于主要操作为查找，并且插入和删除操作只在尾部进行的场景|适用于频繁对线性表进行任意位置的插入和删除操作的场景|
|访问特性|随机存取（直接存取）|顺序存取|

## 栈和列表

### 栈

#### 定义

栈定义为：限定只在表的一端（表尾）进行插入和删除操作的线性表。
我们用指针`top`指向栈顶，即待插入元素的位置，用`bottom`指向线性表的另一端。

##### 抽象数据类型定义

ADT Stack{
  数据对象 : $D=\{a_i|a_i\in ElemSet,i=1,2,\cdots,n,n\geq 0\}$
  数据关系 : $R=\{<a_{i-1},a_i>|a_{i-1},a_i\in D,i=2,\cdots,n\}$
  (约定 $a_n$端为栈顶，$a_1$端为栈底)
  基本操作：见数据结构实现文档
}

#### 栈的存储结构

##### 顺序栈

当 `base == NULL`时，表明栈结构不存在
当 `base == top`时，说明栈空
当 `top-base == stacksize`时，说明，栈满

##### 链栈

本质为不带头结点的单链表。

##### 静态分配整型指针

用一个固定大小的数组来模拟栈。

#### 栈的应用

##### 求解表达式 

利用运算符栈和数字栈来求解表达式，运算符的入栈标准为，要比栈中的运算符先执行，因此如果栈中有优先级相同的运算符，则需要先执行栈中的运算符。

##### 中缀表达式转换为后缀表达式

后缀表达式中，靠前的运算符先执行，为此我们利用一个后缀表达式栈和运算符栈，
数字都存入后缀表达式栈中，运算符先进入运算符栈中，如果加入的加入新的运算符的标准是已有的运算符都在它之后执行，因此如果有与其同级的运算符，则需要先将栈顶的运算符移至后缀表达式栈中。最后结果是后缀表达式从栈底到栈顶输出。

### 队列

#### 基本定义

队列即限定在表的一段进行删除，在表的另一端进行插入操作的线性表，允许删除的一段称为队头，允许插入的一段叫做队尾

##### 抽象数据类型定义

ADT Queue{
  数据对象：$D=\{a_i|a_i\in ElemSet,i = 1,2,\cdots,n,n\geq 0\}$
  数据关系：$R=\{<a_{i-1},a_i>|a_{i-1},a_i\in D,i=2,\cdots,n\}$
  （约定 $a_n$端为队尾，$a_1$端为队头）
  基本操作：见数据实现文件
}

#### 队列的存储结构

##### 链队列

本质是带头节点的线性链表。
含有两个指针，队头指针指向头节点，队尾指针指向尾结点，当两者同时指向头节点时，队列为空。
链队列进行删除时，如果队列变为空，则除了调整头指针外，还需要将尾指针置为`NULL`。

##### 循环队列——队列的顺序存储结构

###### 基本定义

顺序队列用一组地址连续的存储单元依次存放从队列头到队列尾的元素。
取药两个指针，一个指向队列头一个指向队列尾

只能用静态数组实现，初始状态为`Q.front=Q.rear=0`,`Q.rear`指向待添加元素的位置(称为虚指),`Q.front`指向待删除的队头（称为实指）。
添加和删除元素时，指针均后移。
为了避免假满，我们要使用循环队列。此时为了避免队满误判为队空，约定用`(Q.rear+1)%MAX_SIZE==Q.front`来判断是否队满，这种方式会不可避免地浪费一个位置。
也可以使用一个计数器来记录队列中元素的个数或者设一个标志变量来区别队列是空是满。

## 串

### 基本定义

串是由多个或零个字符组成的有限序列，记作$S=c_1c_2\cdots c_n(n\geq 0)$。
其中S是串名字， $c_1\cdots c_n$是串值。

子串即串中任意个连续的字符组成的子序列。主串则是包含子串的串。字符在串中的位置
即字符在序列中的序号，子串在串中的位置则是子串的第一个字符在主串中的位置。

当且仅当两个串的长度相等，且对应位置上的字符相等，则我们称它们相等。

如果一个串只由一个或多个空格组成，则称为空格串。

我们用单引号来表示串。

对于串的操作都是以“串”的整体为操作对象。

ADT string{
  数据对象：$D=\{a_i|a_i\in 字符集,i=1,2,\cdots,n,n\geq 0\}$
  数据关系：$R=\{<a_{i-1},a_i>|a_{i-1},a_i\in D,i=1,2,\cdots,n\}$
  基本操作：见数据实现文件
}

## 数组和广义表

一维数组具有线性表的结构，一般不进行插入和删除操作，只定义给定下标读取元素和修改元素的操作。

二维数组中，每个数据元素对于一对数组下标，在行方向上和列方向上都存在一个线性关系，即存在两个前驱和两个后继。也可以看作是以线性表为数据元素的线性表。

更一般地，n维数组中，每个数据元素对应n个下标，受n个关系的制约，其中任一关系都是线性关系，可以看作是数据元素为n-1维数组的一维数组

ADT Array{
  数据对象： $j_i=0,\cdots,b_{i-1},i=1,2\cdots,n,D=\{a_{j_1j_2\cdots j_n}|n(>0)称为数组的维数,b_i是数组第i维的长度,j_i是数组元素的第i维下标,a_{j_1j_2\cdots j_n}\in ElemSet\}$
  数据关系： $R=\{R_1,R_2,\cdots,R_n\}$
  $R_i=\{<a_{j_1\cdots j_i\cdots j_n},a_{j_1\cdots j_{i+1}\cdots j_n}>|0\leq j_k\leq b_k-1,1\leq k\leq n\}且k\neq i,0\leq j_i\leq b_i-2,a_{j_1\cdots j_i\cdots j_n},a_{j_1\cdots j_{i+1}\cdots j_n}\in D,i=2, \cdots,n\}$
}

数组中从高维映射的到一维的方式即元素之前以及存储了的元素个数。对于二维数组，分为行优先和列优先。

## 树和二叉树

### 树的定义和基本术语

#### 树的定义 

树是由 $n(n\geq 0)$个结点组成的有限集合。如果 $n=0$，称为空树；如果 $n>0$，则有一个特定的称为根的结点，它只有后继，没有前驱。除根以外的其他结点划分为 $m(m\geq 0)$个互不相交的有限集合 $T_0,T_1,\cdots,T_{m-1}$，每个集合本身又是一棵树，并且称之为根的子树。每棵子树的根节点有且仅有一个直接前驱，但可以有0个或多个后继。

#### 树的基本术语 

1. 结点：包含一个数据元素及若干指向其子树的分支
2. 度（次数、级）
   1. 结点的度：一个结点所拥有的子树的个数
   2. 树的度：树内各结点的度的最大值
   3. 叶子（终端结点）：度不为0的结点
   4. 分支（非终端）结点：度不为0的结点
3. 结点之间的关系：
   1. 孩子：一个结点的子树的根
   2. 双亲：B结点是A结点的孩子，则A结点是B结点的双亲
   3. 兄弟：同一个双亲的孩子之间互称兄弟
   4. 祖先：结点的祖先是从根到该结点所经分支上的所有结点
   5. 子孙：以某结点为根的子树中任意结点都称为该结点的子孙
3. 层次：
   1. 结点的层次：根据结点的层定义为1，其孩子结点的层为第二层，以此类推。
   2. 树的深度（高度）：树中最大的结点层。
4. 路径：树中的结点序列，前一个结点是最后一个结点的双亲或孩子。
5. 无序树：子树有序的数，如家族树 
6. 无序树： 不考虑子树的顺序
7. 森林： m($m\geq 0$)棵互不相交的树的集合。

一个树去掉其根节点，其子树就构成了一个森林。

#### 树的抽象数据类型

ADT Tree{
  数据对象D:D是具有相同特性的数据元素的集合
  数据关系R：

  - 若D是空集，则称为空树
  - 若D仅含一个数据元素，则R为空集
  - 否则R={H},H是如下二元关系：
    - 在D中存在唯一的称为根的数据元素root，它在关系H下无前驱；
    - 若D-{root}$\neq\varnothing$，则存在D-{root}的一个划分 $D_1,D_2,\cdots,D_m(m>0)$，对任意 $j\neq k(1\leq j,k\leq m)$有$D_j\cap D_k=\varnothing$，且对任意的 $i(1\leq i\leq m)$，存在唯一数据元素$x_i\in D_i$，有 $<root,x_i>\in H$
    - 对应于 D-{root}的划分，$H-\{<root,x_1>,\cdots,<root,x_m>\}$有唯一的一个划分 $H_1,H_2\cdots,H_m(m>0)$，对任意 $j\neq k(1\leq j,k\leq m)$有$H_j\cap H_k=\varnothing$，并且对任意的 $i(i\leq i\leq m)$，$H_i$是 $D_i$上的二元关系，$(D_i,{H_i})$是一棵符合本定义的树，称为根root的子树。

}

### 二叉树

#### 二叉树的定义

一颗二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。

二叉树的特点在于：

1. 每个结点的度小于等于2；
2. 是有序树

注意，二叉树也可以是空树，这也使得按照定义，二叉树的每个结点都有一个左子树和一个右子树。
ADT Tree{
  数据对象D:D是具有相同特性的数据元素的集合
  数据关系R：

  - 若D是空集，则称为空二叉树
  - 若D仅含一个数据元素，则R为空集
  - 否则R={H},H是如下二元关系：
    - 在D中存在唯一的称为根的数据元素root，它在关系H下无前驱；
    - 若D-{root}$\neq\varnothing$，则存在D-{root}的一个划分 $D_1,D_2$，有$D_1\cap D_2=\varnothing$
    - 若$D_1\neq\varnothing$，则 $D_1$中存在唯一的元素 $x_1,<root,x_1>\in H$，且存在 $D_1$上的关系 $H_1\subseteq H$；若$D_2\neq\varnothing$，则 $D_2$中存在唯一的元素 $x_2,<root,x_2>\in H$，且存在 $D_2$上的关系 $H_2\subseteq H$；$H=\{<root,x_1>,<root,x_2>,H_1,H_2\}$；
    - $(D_1,\{H_1\})$是一棵符合本定义的二叉树，称为根的左子树，$(D_2,\{H_2\})$是一棵符合本定义的二叉树，称为根的右子树。

}

#### 二叉树的性质

1. 若二叉树的层次从1开始，则在二叉树的第i层最多有 $2^{i-1}$个结点$(i\geq 1)$
2. 深度为k的二叉树最多有$2^k-1$个结点 $(k\geq 1)$
3. 对任何一棵二叉树，如果其叶节点的个数为$n_0$，度为2的非叶结点个数为 $n_2$，则有 $n_0=n_2+1$

#### 满二叉树

深度为k且有 $2^k-1$个结点的二叉树是满二叉树（根结点的深度为1）。编号方式为从上至下，从左至右。

#### 完全二叉树 

深度为k，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应时，称之为完全二叉树。

##### 完全二叉树的性质

1. 若设二叉树的深度为h，除第h层外，其他各层的结点数都达到最大个数，第h层从右向左连续缺若干结点。
2. 叶子结点均位于最下面二层
3. 任一结点，若其右子树的最大层数是L，其左子树的最大层数是L或L+1。
4. 具有n个结点的完全二叉树的深度为$\lfloor \log_2^n\rfloor+1$
5. 如果将一颗有n个结点的完全二叉树的结点按层序（自顶向下，同一层自左向右）连续编号$1,2,\cdots,n$，然后按此结点编号将树中各结点顺序地存放于一个一维数组中，并简称编号为i的结点为结点i。则有一下关系：
   1. 若i=1，则i是二叉树的根，无双亲；若i>1，则i的双亲为$\lfloor i/2\rfloor$
   2. 若$2i\leq n$，则i的左孩子为2i，否则无左孩子；若$2i+1\leq n$，则i的右孩子为2i+1，否则无右孩子。
   3. 若i为偶数，且 $i\neq n$则其右兄弟为i+1;若i为奇数，且$i\neq n$，则其左兄弟为i-1。
   4. i所在层次为 $\lfloor\log_2^i\rfloor+1$。
6. 在n个结点的完全二叉树中：
   1. 度为1的结点数为$(n+1)%2$
   2. 度为0的结点数为$\lfloor(n+1)/2\rfloor$
   3. 度为2的结点数为$\lfloor(n+1)/2\rfloor-1$
7. n个结点的二叉树共有 n+1个空指针

### 二叉树的存储结构

#### 顺序存储结构

用数组来表示，任一二叉树对照完全二叉树进行存储，即结点在向量中的相对位置蕴含着结点之间的关系。

缺点在于会造成存储空间的浪费。

#### 链式存储结构

##### 分类

从数据结构设计上可以分为二叉链表和三叉链表，前者中每个结点存储着指向其左右孩子结点的指针，而后者在此基础上还增加了指向其双亲结点的指针。

从变化程度上可以分为动态和静态。动态树采用动态申请内存空间，而静态树则是使用一个结点数组来存储数组，用下标来代替指向结点的指针。

### 遍历二叉树

树的遍历，就是按照某种次序访问树中的结点，要求每个结点访问一次且仅访问一次。

遍历的结果即产生一个关于结点的线性序列。

#### 遍历方式 

记访问根结点为D，其左右子树分别记为LR，则遍历次序有：先序，中序，后序，逆先序，逆中序，逆后序。前三者中，LR的相对顺序为LR，而后三者中为RL。前中后描述的是D在其中的位置。

先中后序中，LR的相对位置不变，变的是D的位置，逆序则是将LR互换

遍历的第一个结点：

1. 先序：根节点 
2. 中序：沿着根节点的左链，直到遇到一个没有左孩子的结点
3. 后序：沿着根节点的左链，直到遇到一个既没有左孩子，也没有右孩子的结点

遍历的最后一个结点：

1. 中序：从根节点出发，沿右链，直到找到一个没有右孩子的结点
2. 后序：根节点 
3. 先序：沿着根节点出发，沿着右链走。走不动了，如果有左孩子，就朝左走，一旦可以朝右走，那就朝右走，即沿着右轮廓走，直到一个没有孩子的结点。

#### 非递归遍历

```cpp
//二叉树非递归遍历访问模板
struct SElemType{BiTree p;int tag;}
void inorder(BiTree T){
  SElemType elem;
  BiTree P = T;
  stack<SElemType>S;
  while(!S.empty()||P){
    while(P){
      //此处调用访问函数，是先序遍历
      elem={P,0};
      S.push(elem);
      P=P->lchild;
    }
    elem = S.top();
    S.pop();
    P = elem.p;
    if(elem.tag==0){//此处调用访问函数，是中序遍历
      elem.tag =1;
      S.push(elem);
      P=P->rchild;
    }
    else{//此处调用访问函数，是后续遍历
      P=NULL;
    }
  }
}
```

#### 重构二叉树

根据先序访问序列和中序访问序列来还原树时，根据先序访问序列来判断根节点，然后在中序访问序列中查找该根节点，其左侧的是在该根节点的左侧。

#### 线索化二叉树

即如果结点没有左孩子，则左孩子的指针域内存储的是指向其前驱的指针；如果结点没有右孩子，则右孩子的指针域内存储的是指向其后继的指针。其实质是对一个非线性结构进行线性化操作，使得每个结点（除第一个和最后一个）在这些线性序列中仅有一个直接前驱和直接后继

### 树和森林

#### 存储结构

分为定长和不定长结构。一般采用定长结构，和不定长结构相比，指针利用率不高，但是算法更简单。当定长结构为二叉树时，指针利用效率最高。树转换为二叉树时遵循“左孩子，右兄弟”的规则。

除此之外，还有一些其他的存储结构

1. 双亲表示法：用结构数组——树的顺序存储方式，一个结点由数据域，以及其双亲的下标，树的结构体由数组以及根节点的下标以及结点的个数组成
2. 孩子链表表示法：由结构数组构成，每一个元素中包含着由其孩子节点构成的链表。
3. 孩子兄弟表示法：即二叉链表表示法

#### 树和森林之间的转换

树和森林之间存在相互递归的关系，树可以视为一个$(root,F)$，其中$root$为树的根节点，$F$则是其子树的集合，是森林。

森林和树相互转换时，森林中的各个树的根节点视为兄弟，然后均遵循“左孩子，右兄弟”的规则

#### 树的遍历

1. 先根遍历：先访问根节点，后依次遍历每颗子树，对应二叉树的先序遍历
2. 后根遍历：先遍历每颗子树，再访问根节点，对应二叉树的中序遍历

#### 森林的遍历

1. 先根遍历：访问根结点，遍历第一颗子树，遍历其他子树。对应先序
2. 中根遍历：遍历第一颗子树，访问根节点，遍历其他子树。对应中序
3. 后根遍历：遍历第一颗子树，遍历其他子树，访问根节点。对应后序
4. 广度优先遍历（层次遍历）:遍历根节点，遍历根节点的所有孩子

### 赫夫曼树及其应用

#### 路径长度

1. 两个结点间的路径长度即连接两结点的路径上的分支数，两个有着父子关系的结点之间的路径长度为1
2. 树的路径长度即根结点到每个结点的路径长度之和
      - 显然，当结点数一定时，完全二叉树的路径长度最小
      - 有着$n$个结点的二叉树的路径长度的上界为$\sum_{i=1}^n\lfloor \log_2i\rfloor=0+1+1+2+2+2+2+3+\cdots$
      - 树的带权路径长度即树的各叶子结点所带的权值与该结点到根的路径长度的乘积之和。当权值均为1时，便是路径长度。

#### 赫夫曼树 

给定带有权重的若干叶子结点，构成的带权路径长度最小的二叉树即赫夫曼树。
在赫夫曼树中，权值大的结点离根最近。

#### 赫夫曼树的应用

1. 在解决某些判定问题时，利用赫夫曼树可以得到最佳判定算法 
2. 用于数据压缩，适用于字符频率不等，差别较大的情况。不同的分布频率会有不同的压缩比率。
3. 归并法外排序，合并顺串。

在数据压缩的应用中，数据的各个组成部分分别对应一个叶子节点，出现的频率与其对应的叶子节点的权重成正比。由此构造出来的赫夫曼树可以用于数据压缩，从根节点到各叶子结点的路径与各叶子结点对应的编码相对应。如果沿着左链下降，则对应位为0，右链则为1。在解码时，便根据该规则从根节点出发，易知这种编码是无前缀的编码，即一个编码不会是另一个编码的前缀，在解码时不会产生混淆。

### 有关树的计数问题

由于中序遍历的栈操作序列与二叉树是一一对应的。因此给定 $n$个结点，由此构造出的二叉树的数量等于 $n$个元素合法进出栈序列的数量，即卡特兰数$\binom{2n}{n}/(n+1)$