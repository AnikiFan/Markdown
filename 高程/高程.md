# 高程

## 第二章

**一定要一句一行**  
**鼓励复用函数**  
取反就是0，1互换  
~~原码换算为补码的逆运算是-1，取反,再变为相反数~~


以2字节-32768为例，先将其转换为其绝对值的二进制1后面在跟15个0,此时最前面的1代表着$2^{15}$也就是10进制里的32768,取反得到0后跟15个1,加一便得到1后面跟15个0,也就是原码中的-0  

要注意的时上面这个案例是极端的,在正数的原码中,第一位永远是0,而在负数的绝对值所对应的二进制中只有像上面的例子那样的极端情况才会在第一位出现1,只有此时绝对值的二进制和其原码不对应,是个特例,其他的时候绝对值的二进制表示和其原码都一样


- [x] 课后check一下


|原码|补码|
|--|--|
|-0|-32768|
|-1|-32767|
|...|...|
|-32767|-1|

负数的原码加补码等于-32768 即$-2^{15}$
计算机里对于整数的表达只有补码,没有原码
补码通过将正负0的补码统一成全都是0来消除0的二义性,也就是说它把原先的负0给消除了,这使得补码可以比原码多表示一个数,那就是-32768  
应该先去判断一个数是什么类型再去判断它的值
不同编译器的数据的长度可能不同

**对于整数型,必须占满对应字节长度**
输出的数字不会标注进制 

***每个文件都应该检查一遍配置属性 链接器 系统 子系统是否为控制台***
## 二进制与十进制小数之间的转换 

当遇到带有小数点的十进制时,并且想将其转换为二进制,对于其整数部分我们只需用常规的短除法来操作,对于其小数部分,我们将单独处理它.  
首先,写下0.xxx,其中xxx为小数点后的部分,然后我们将这个数字乘以2,取得到的数字的个位数
这个数字便是对应十进制的小数点后第一位,如果这个数字是1,那么我们在下一次操作时将这个一改为0,如果是0,那么保持不变,下一步操作是继续乘以2 ,当取了n个数后所得的数字小数点后都是0了,那么就停止操作,我们便得到了十进制下的小数.  

如果想要将二进制小数转换成为十进制小数,只需和整数部分一样采用加权展开即可.  


**要注意当把八进制或者十六进制转换为二进制时,转化的过程中间应该严格遵循1位对应3或者4位二进制,在写答句的时候可以省略最前面的0**

**需要记忆最基本的字符的ascii码**

***在正确情况下按最长原则来判别\代表什么字符 如\123应该理解为\123而不是\1和23或\12和3,对于\x而言,后面不能跟3位及以上的16进制,如fff,会报错,但是二位16进制后可以跟其他的非0-9,a-f的字,如空格***
*字符串结尾不能为\0*
c和c++中但有害和双引号有严格区别,一个是字符一个是字符串
\是转义符,\+一个字符将它转换为另外一个字符,也就是\+一个字符在内存中是另外一个字符,\不会出现在内存中
字符串的尾0的\0就是被转义到了另外一个字符,因此字符串在内存中的实际字符会多一个

***应该避免使用全文替换***

标识符长度意味着只会截取前面多少位字符,如果长度限制是2,那么对于abc和abd,两个都是合法的,但是计算机只会取前面两位即ab

dev中不支持用中文来当标识符,因此应该尽量不用
*禁用auto*
*42页第二个框中输出abc是什么,语句执行是从左到右,单个语句内部也是,a=b=c=10是先定义a并把b赋值给a,然后把c赋值给b,此时变量a,b实际上都是c的值,然后再把10赋值给c,这是abc应该都是10*

数据的溢出可以理解为65536进制(2字节)
以一字节signed char为例
|...|0111 1111|1000 0000|...|1111 1110|1111 1111|0000 0000|0000 0001|
|---|----|----|----|----|----|---|----|
|...|127|-128|...|-2|-1|0|1|
可以看出来二进制补码对应的十进制是一个循环,达到最大值127后的下一位便是最小值-128然后不断上升
当第一位为1时,补码对应的十进制是负数,其对应的数和正数一样位权展开,只不过此时的1和0颠倒且是从-1开始加的,即1000 0000=-1
同时也可以理解为以0000 0000=0为基准,然后位权展开,一直累加到127后下一位从-128开始,因此1111 1111是-1,这样来看的话,第一位在1,0之间变换时,会前进\后退128位,例如从0到-128,无论怎样0一定在这两个位置之间,因此两个位置对应的十进制的绝对值之和是128

对于同长度的signed与unsigned互相赋值时,两者对应的十进制的绝对值之和等于2^总位数,如char的话便是258
可以这样理解
|二进制|0000 0000|0000 0001|...|0111 1111|1000 0000|1000 0001|...|1111 1111|
|---|---|---|---|---|---|--|--|---|
|unsigned|0|1|...|127|128|129|...|257|
|signed|0|1|...|127|-128|-127|...|-1|
因此两者在对于首位为1的二进制的处理上发生了差异,在于两者对于128从那里开始不同
|-128|...|-1|0|1|...|127|128|...|257|
|--|--|--|--|--|--|--|--|--|--|
|signed起始处| | | | | | | unsigned起始处 |||
因此两者绝对值之和为258

47页unsign和sign的绝对值相加为65536,快速计算

strlen只能输入字符串而不能输入字符char,输出的是字符串中字符的个数,不包括尾零,而sizeof既可以输入字符也可以输入字符串,输出的是输入在内存中的字节,因此在输入字符串时会将尾零算入

|输出\输入|unsigned 短|signed 短|
|--|--|--|
|unsigned长|无影响|负数会改变|
|signed长|无影响|负数会改变|
### 编译器输出字符

所谓的非法输出是指输出结果并不可信,字体,大小,控制台等等条件都肯能改变非法输出的内容
### 符号常量
>可以理解为定义缩写
本质上就是定义了标识符a来代替某一字符串
\#define a b;
上面这行实际上就是把其下面的代码中的a全都换为了b;
本质就是文字替换
>

*整数相除\是直接舍去小数,整除%结果用竖式除法来解决*

### 栈的运算
加入栈的运算符应该是在之前的栈顶运算符之前或者同时生效的运算符,即和它等级相同且右结合(从右往左)或者比它运算等级高,若是之后生效的,即等级更低或者左结合(从左往右)

a
B  \\
对于这种与顺序相关的运算,正确的应该是B\A,即从下往上取,从左往右列
### 类型转换
short a=1 ,b=a+1得到的b是short
而short a=1,b=1,a+b是int
类型转换是按需转换,只有在必要的时候才会进行
float型转换为char\short\int等整数特有的类型时会忽视掉其小数,溢出的处理方法和长变短字节的处理相同,即直接切掉前面的
-[ ] 其他类型准换到float以及float支持的范围,搜索资料

### 自增与自减
当自增与自减位于前面作为前缀时,会直接将其后面的变量加一\减一,作为后缀时,vs会先将原值赋值到一个中间变量中,以它来代替原先的变量来接受其他运算,之后在把原变量加一,而dev则是相反,先将原变量加一,在将加一\减一之前的变量复制到中间变量来进行后续运算,区别在于前者的加一减一操作是在最后执行,而后者不是,从而有可能被后续操作覆盖
前缀效率更高,因为不会创建中间变量

## 程序编写细节处理

一个语句一行
变量名不要用中文
不要使用全文替换
推荐使用常变量而不是符号变量
禁用goto语句
单语句时就不用加{}了,避免累赘
要正确缩进,增加可读性 
**禁止使用==来判断是否相等,应该使用绝对值的误差小于一个很小的数来避免浮点数带来的误差**
vs中使用sin等数学公式时不需要cmath的头文件,但是如果要使用的话一定要加上去
推荐格式
``` c++
#include <iostream> 
#include <cmath> //数学函数对应头文件，VS可省略 
using namespace std; 
int main() 
{	double a = 0, b = 5.78 * 3.5, c = 2 * sin(2.0);
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;
	return 0;
}
```

### IEEE754

IEEE754标准下所能表示的浮点数$v$的二进制形式形如 $$
(-1)^s2^E(b_0.b_1b_2\dots b_{23})$$
其在内存中占4字节,即32位,可分为三段

1. 符号位:第1位(从左往右,下同),其值记为s,只可能为0或1.为0时尾数为正,为1时尾数为负
2. 指数:第2-9位,其十进制值记为e,范围为0-255减去偏置值127后得到的数记为E,范围为-127-128,从而指数有了正负之分
3. 尾数:第10-32位,记为$f,f=b_1b_2\dots b_{23}$

特殊情况以及$b_0$由以下条件决定:

1. e=255且$f\ne0$时,该$v$表示NaN(Not a number)
2. e=255且f=0,则$v=(-1)^s\infty$
3. 若$0<e<255$,则$b_0=1,v=(-1)^s2^E(b_0.b_1b_2\dots b_{23})$(二进制),称为规格数
4. 若$e=0$且$f\ne0$时,则$b_0=0,v=(-1)^s2^{-126}(b_0.b_1b_2\dots b_{23})$(二进制),称为非规格数
5. 若e=0且f=0,则$v=(-1)^s0$

因此想要得到float型的最大值,应令$s=0,e=254,b_i=1,1\le i\le23$,得到值为
$$
2^{127}(0b1.11111111111111111111111)\approx3.4\times10^{38}
$$
下面探究float型对应的十进制有效位数.  
当我们说有x位有效位数时,即float型能够表示在float型的正最小值到正最大值和负最小值到负最大值这一范围之内的所有有效位数为x的十进制数.
由于对称性,只需考虑$s=0$的情况.
- 规格数

所能表示的十进制数可以分为254个等差数列
|E|首项|公差|末项|首末项之间所能表示的有效位数|
|--|--|--|--|--|
|-126|$2^{-126}\approx 1.2\times10^{-38}$|$2^{-126}\times2^{-23}=2^{-149}\approx1.4\times 10^{-45}$|$2^{-126}\times(2^1-2^{-23})=2^{-125}-2^{-149}\approx2.4\times10^{-38}$|7位(从小数点后44位至小数点后38位)|6位|
|...|...|...|...|...|...|
|0|$2^0=1$|$2^{-23}\approx1.2\times 10^{-7}$|$2^1-2^{-23}\approx2$|7位(从小数点后6位至整数部分第1位)|6位|
|...|...|...|...|...|...|
|10|$2^{10}\approx1.02\times10^{3}$|$2^{10}\times2^{-23}\approx1.2\times10^{-4}$|$2^{10}\times(2^1-2^{-23})\approx2.05\times10^{3}$|7位(从小数点后3位至整数部分第3位)|6-7位|
|...|...|...|...|...|...|
|127|$2^{127}\approx1.7\times10^{38}$|$2^{127}\times2^{-23}=2^{104}\approx2.03\times10^{31}$|$2^{127}\times(2^1-2^{-23})=2^{128}-2^{104}\approx3.4\times10^{38}$|7位(从整数部分第32位至整数部分第38位)|6位|


值得注意的是,这里的有效位数7并不代表float型中就无法存储更多位数的数了,例如$2^{-126}+2^{-149}\approx1.1754944909521339404504436295952\times10^{-38}$,它就可以完整地在float型中储存下来.


理论上浮点数所能表示的有效位数最大值位7位,因为 $$
 n_{理论最大}=\lfloor\lg(2^i-\frac{1}{2}\times2^{i-23})\rfloor-\lfloor\lg2^{i-23}\rfloor\le\lfloor\lg(2^i-\frac{1}{2}\times2^{i-23})-(\lg2^{i-23}-1)\rfloor=\lfloor23\lg2+\lg(1-2^{-24})+1\rfloor=7
$$
上式是利用首项和公差来计算有效位数的,一般而言首项与末项的指数相同,但是也有可能末项的指数比首项的指数大1.
由表可知,一般而言,浮点数所能表示的有效位数为7位,但是该标准中,若准备将数A存储进浮点型,实际对应的浮点数所表示的数实际上是数B,距离数A最近且能被浮点型直接表示的数.如果同时有两个符合条件的数B,则取内存中最后一位为0的数,即较小的那个数.


因此,即使理论上可以表示7位有效数字,但是因为这一取整机制,某些数字在存储进浮点型只有6位有效数字被保留,例如1024.001,对应浮点数在内存中的4字节为`0100 0100 1000 0000 0000 0000 0000 1000`,其对应的十进制为1024.000977,即只有6位有效数字被保留了下来.  


而对于1024.003,对应浮点数在内存中的4字节为`0100 0100 1000 0000 0000 0000 0001 1001`,对应十进制为1024.003052,即7位有效数字被保留了下来.

***

IEEE754标准下所能表示的double型数据$v$的二进制形式形如 $$
(-1)^s2^E(b_0.b_1b_2\dots b_{52})$$
其在内存中占8字节,即64位,可分为三段

1. 符号位:第1位(从左往右,下同),其值记为s,只可能为0或1.为0时尾数为正,为1时尾数为负
2. 指数:第2-12位,其十进制值记为e,范围为0-2047减去偏置值1023后得到的数记为E,范围为-1023-1024,从而指数有了正负之分
3. 尾数:第13-64位,记为$f,f=b_1b_2\dots b_{52}$

特殊情况以及$b_0$由以下条件决定:

1. e=2047且$f\ne0$时,该$v$表示NaN(Not a number)
2. e=2047且f=0,则$v=(-1)^s\infty$
3. 若$0<e<2047$,则$b_0=1,v=(-1)^s2^E(b_0.b_1b_2\dots b_{52})$(二进制),称为规格数
4. 若$e=0$且$f\ne0$时,则$b_0=0,v=(-1)^s2^{-1022}(b_0.b_1b_2\dots b_{52})$(二进制),称为非规格数
5. 若e=0且f=0,则$v=(-1)^s0$

因此想要得到float型的最大值,应令$s=0,e=2046,b_i=1,1\le i\le52$,得到值为
$$
2^{2046}(0b1.1111111111111111111111111111111111111111111111111111)\approx1.7977\times10^{308}
$$
下面探究double型对应的十进制有效位数.  
由于对称性,只需考虑$s=0$的情况.
- 规格数

所能表示的十进制数可以分为2046个等差数列
|E|首项|公差|末项|首末项之间所能表示的有效位数|
|--|--|--|--|--|
|-1022|$2^{-1022}\approx 2.2\times10^{-308}$|$2^{-1022}\times2^{-52}=2^{-1074}\approx4.9\times 10^{-324}$|$2^{-1022}\times(2^1-2^{-52})=2^{-1021}-2^{-1074}\approx4.5\times10^{-308}$|16位(从小数点后323位至小数点后308位)|6位|
|...|...|...|...|...|...|
|0|$2^0=1$|$2^{-52}\approx2.2\times 10^{-16}$|$2^1-2^{-52}\approx2$|16位(从小数点后15位至整数部分第1位)|6位|
|...|...|...|...|...|...|
|1023|$2^{1023}\approx8.99\times10^{307}$|$2^{1023}\times2^{-52}=2^{971}\approx1.996\times10^{292}$|$2^{1023}\times(2^1-2^{-52})=2^{1024}-2^{971}\approx1.8\times10^{308}$|15位(从整数部分第293位至整数部分第307位)|6位|
理论上浮点数所能表示的有效位数最大值位16位,因为 $$
n_{理论最大}=\lfloor\lg(2^i-\frac{1}{2}\times2^{i-52})\rfloor-\lfloor\lg2^{i-52}\rfloor\le\lfloor\lg(2^i-\frac{1}{2}\times2^{i-52})-(\lg2^{i-52}-1)\rfloor=\lfloor52\lg2+\lg(1-2^{-54})+1\rfloor=16
$$
上式是利用首项和公差来计算有效位数的,一般而言首项与末项的指数相同,但是也有可能末项的指数比首项的指数大1.
由表可知,double型数据所能表示的有效位数也可能为15位,例如1.234567890123456e307,对应double型数据在内存中的8字节为`0111 1111 1011 0001 1001 0100 1011 0001 0100 1011 1110 0010 0111 1001 1110 0001`,其对应的十进制为1.2345678901234559417535490591099e+307,即只有15位有效数字被保留了下来.

而对于1.234567890123456,对应浮点数在内存中的8字节为`0011 1111 1111 0011 1100 0000 1100 1010 0100 0010 1000 1100 0101 1001 1111 1000`,对应十进制为1.234567890123456,即16位有效数字被保留了下来.

---

#编译器相关内容
编译器不会回溯,因此假如少加了一个;,编译器会认为语句没有结束,从而继续跳到下一行,因此因为,没有加;造成的错误要到下一行时编译器才会检查出来,它也只会报下一行.即在;后的一行出错,而不是;应该在的地方

---

## 结构化程序设计基础



cout是流对象调用而printf是函数调用,两者并不相容
*switch中的case满足后会依次运行之后的case,除非遇到break*
swith的语句序列不用加{}
continue会无视switch语句

***

## 函数

**前缀自增自减会先被执行,然后返回被自增自减后的值,如++i,--i,后缀的话顺序相反**

## 递归

递归即在函数中调用该函数本身,用于解决递推类问题. 
在编写递归函数之前要确认:

- 该函数要输出什么
  - 递归函数中递推关系的起始输出项,例如递推数列中的$a_{n_0}$的值以及$n_0$本身
- 递推关系是什么
  - 后续的输出项与之前的输出项有什么递推关系
  - n是如何回退至其实输出条件的
- 在每一层递推中,递推项i的值都不应改变,每一层的i都独自占用一个形参,是相互隔离的

大致的结构为

``` c++
int fun(递推项i)//递推函数中的递推项i遵循底层屏蔽高层的原则,与一开始的回推起始项这个实参是隔离开来的
{
    if(i==递推起始条件){
		return 起始输出项;
    }
    else{
    i以及fun(i-1)进行运算;//fun(i-1)即对于第i-1项的预期输出,这里的i-1不能改为--i,更不能该为i--,
    //前者是因为下一句是输出第i项的预期输出,当--i时确实会将i-1赋给下一个形参,但是同时会改变该层的形参i,导致一句return无法输出预计值,
    //而后者是先将i输入至fun内在进行i-1的操作,从而导致死循环
    return 对于第i项的预期输出;
    }
}
int main()
{
    fun(回推起始项);//给出的是回推起始项对应的预期输出,实参赋值给形参
}
```

该结构的递归函数只返回一个值,并不进行输出输入等操作

``` c++
void fun(递推项i)//递推函数中的递推项i遵循底层屏蔽高层的原则,与一开始的回推起始项这个实参是隔离开来的
{
    if(i==递推起始条件){
		return ;
    }
    else{
    对i进行操作,如运算,输出等,但不能包含fun(i-1);
    fun(i-1)//或者其他的能使i回到递推起始条件的语句
	return ;
    }
}
int main()
{
    fun(回推起始项);//给出的是回推起始项对应的预期输出,实参赋值给形参
}
```

## 数据输入处理专题

|函数名|返回值类型|单次读入字符数量|回车后光标位置|回显|回车后开始读取|输入后立刻读取|对空格的处理|对回车的处理|
|--|--|--|--|--|--|--|--|--|
|getchar()|ASCII码|一个|回显下一行|原处回显|是|否|光标移至下一行,返回32|光标移至下一行,返回10|
|_getch()|ASCII码|一个|原处|无|否|是|光标不动,返回32|光标不动,返回13|
|_getche()|ASCII码|一个|紧跟回显|原处回显|否|是|输出空格,返回32|光标不动,返回13|
|cin.get()|ASCII码|一个|回显下一行|原处回显|是|否|光标移至下一行,返回32|光标移至下一行,返回10|
|cin.get(存储数组,字符个数n,终止字符(默认为回车))|ASCII码|n-1个(终止字符不返回,保留在缓存区中,尾部会添加尾零)|回显下一行|原处回显|是|否|输出空格,返回32|光标移至下一行,返回10|
|cin.getline(存储数组,字符个数n,终止字符(默认为回车))|ASCII码|n-1个(终止字符不返回,从缓存区中去除,尾部会添加尾零)|回显下一行|原处回显|是|否|输出空格,返回32|光标移至下一行,返回10|
|cin.peek()|ASCII码|一个|回显下一行|原处回显|是|否|光标移至下一行,返回32|光标移至下一行,返回10|

### 场景1

|场景描述|单次输入个数|回显|输入类型|输入结束条件|输入错误后处理|对空格的处理|对回车的处理|
|--|--|--|--|--|--|--|--|
||1|原处回显|int型|回车|若输入类型错误则清除缓存区|不视为输入|

代码
使用cin输入
```cpp
	cout << "提示句" << endl;
	while (1) {
		cin >> src;
		if ((输入要求) && !cin.rdstate()) 
			break;//输入完成,跳出循环
		else if (cin.rdstate()) {
			cin.clear();
			cin.ignore(10000000, '\n');//输入错误,清除缓存区
		}
		cout << "提示句" << endl;
	}
	//对输入进行额外处理
```

### 场景2

|场景描述|单次输入个数|回显|输入类型|输入结束条件|输入错误后处理|对空格的处理|对回车的处理|
|--|--|--|--|--|--|--|--|
|除了回车外其他的控制字符均不生效|多个|原处回显|char型|回车|若输入错误则清除缓存区|不生效|