# UNIX

## 源代码->磁盘中的可执行文件

下面是一个典型的源代码：

```c
#include<fcntl.h>
char buffer[2048];
int version = 1;
main1(argc,argv)
int argc;
char* argv[];
{
    int a,b;
    ...;
    sum(a,b);
    exit(0);
}
int sum(var1,var2)
int var1,var2;
{
    int count;
    count = var1 + var2;
    return (count);
}
```

其由以下几部分组成：

1. 头文件`#include<fcntl.h>`
2. 全局变量：
   1. 未赋初值`char buffer[2048]`
   2. 赋初值`int version = 1`
3. `main1`函数
4. 形参`argc,argv,var1,var2`
5. 局部变量`a,b,count`

对应的可执行文件为

|内容 | 大小|
|--|--|
|magic number  |             |
|Text段长度信息1024        |         |
|Data段长度信息4        |            |
|BSS段长度信息2048    |         |
|Text段，包含main1()代码，sum()函数代码以及库函数代码|1K|
|Data段|4|

1. 这里的magic number以及长度信息统称为文件头。
2. 这里的Text段和Data段按需分配，不会以4K或其他大小为单位。
3. 这里的BSS是Block Started by Symbol的缩写
4. BSS段长度由未赋初值的全局变量大小决定
5. Data段长度由已赋初值的全局变量大小决定
6. Data段和BSS段可能因为链接的其他文件中的全局变量而更长

## 磁盘中的可执行文件->内存中的进程图像

需要经过以下步骤：

1. 打开文件，读入文件头
2. 分配Text段长度（向上扩展至4K的整数倍）的内存作为代码段
3. 从可执行文件中Text段读取代码段
4. 分配Data段和BSS段长度之和（向上扩展至4K的整数倍）的内存空间作为数据段并清0
5. 从可执行文件中的Data段读取Data段至数据段开头

局部变量和调用函数时所用形参在进程运行时动态存储在用户栈中。

下图为进程图像的总览（物理地址版本）

![alt text](image.png)

1. 用户自己编写的代码，如`main1,sum`以及库函数都属于用户态地址空间
2. 代码段若和PPDA区、数据段和用户栈一同调入内存中，则占用连续的内存空间
3. PPDA是Per Process Data Area的缩写
4. PPDA区，数据段和用户栈若内存不够则可以换出
5. Text段只有当没有在内存中的进程使用时才能换出

## 用户态

物理地址空间4M以上是用户态地址空间

### 用户栈

1. 用户栈从高地址至低地址扩展
2. 用户栈开始时大小为4K
3. 一个函数体对应一个栈帧，从高地址至低地址分别由以下部分组成：
   1. 形参
   2. 返回地址
   3. OLD EBP
   4. 局部变量

![alt text](image-1.png)

调用函数负责逆序压入形参（使得顺序靠前的形参离返回地址近），调用被调用函数（压入返回地址）；被调用函数负责压入OLD EBP，并更新EBP，和顺序放入临时变量。

返回时，被调用函数负责将用户栈还原至进入被调用函数之前的状态，所以需要还原ESP，EBP，弹出并装入EIP。调用函数需要负责删除实参区。

## 中断与核心栈

### 中断的基本流程

在用户态运行时，核心栈为空。当发生中断时，将会启用核心态内存空间。

当进程运行在用户态时，若发生中断，将会依次发生下列事件：

1. 中断隐指令（没有对应汇编语句，只有机器语言）
   1. 关中断
   2. 核心栈寄存器压入核心栈（若之前为用户态，压入SS，ESP，EFLAGS，CS，EIP；若之前为核心态，压入EFLAGS，CS，EIP）
   3. SS段转入核心态
   4. 查找并依据中断向量装入CS和EIP
   5. 跳转至中断处理入口程序（机器语言调用函数）
2. 中断处理入口程序
   1. SaveContext保存中断软件现场
   2. SwitchToKernel将DS和ES转向核心态
   3. 调用中断处理程序（汇编调用函数）
3. 中断处理程序
   1. 可能调用其他**内核态函数**
   2. 很可能会唤醒与本次中断相关的进程
4. 例行调度
   1. 若先前为用户态（根据硬件现场中的CS判断），则直接进一步通过RunRun判断是否需要调度
   2. 若为内核态，进行下一步
5. 恢复中断前现场
6. 中断返回

机器语句和汇编调用函数与C语言调用函数的区别在于，C语言调用函数的语句转为汇编语句时，会自动添加压入形参的语句，但是前面两者不会。这给予了自由操作栈帧的操作。对于跳转至中断入口程序，由于不需要形参，所以不作处理。对于中断处理程序，通过SaveContext来形成所需要的形参。

### 时钟中断

每秒会由于可编程定时芯片触发60次定时中断。

1. 时钟中断处理程序之前与中断的基本流程一致
2. 使用时钟中断处理程序
   1. 若为用户态，当前进程u_time+1，否则当前进程u_stime+1
   2. 当前进程p_cpu+1，上限为1024
   3. Time::lbolt+1
   4. 若Time::lbot<60或中断前为核心态，则发送EOI
   5. 否则
      1. Time::lbolt-60
      2. Time::time+1
      3. 发送STI和EOI并开中断
      4. 唤醒所有延时睡眠进程（因为Sys_sleep睡眠的进程），`WakeUpAll((unsigned long)&Time::tout)`
      5. 所有进程p_time++
      6. 所有进程p_cpu=max(0,p_cpu-SCHMAG)
      7. 重新计算所有优先数p_pri大于PUSER，即在用户态的进程的进程，的优先级p_pri
      8. 如果RunIn设置，则清除标志，并唤醒0#进程
      9. 如果收到信号，则进行信号处理
      10. 重新计算当前进程优先级p_pri
3. 例行中断

### 系统调用中断

与中断的基本流程在于中断处理程序为系统调用处理程序Trap

1. 根据系统调用号获取处理子程序入口表
2. 执行系统调用处理子程序
   1. 可能会执行读文件等IO操作
3. 重算现进程优先数p_pri

一个调用与外设IO相关的系统调用的进程的运行状态变化如下：

1. 使用内嵌汇编调用系统调用函数
2. 执行系统调用处理函数Trap
   1. 执行系统调用处理子函数
      1. 使用外设
      2. 调用Sleep入睡
         1. 用Swtch切换进程
3. 被唤醒
4. 被Swtch选中上台
5. 执行剩余处理子函数和处理函数
   1. 在Trap末尾重算进程优先数
      1. 为了刷掉核心态下的优先级，恢复计算获得的优先数
      2. 现运行进程优先级下降，设置RUnRun
6. 例行调度
   1. 执行Swtch下台
7. 被Swtch选中上台
   1. 退出中断

## 调度

### p_cpu

1. p_cpu代表着进程使用cpu的时长，包括用户态和核心态所用时间
2. 每次脉冲都会更新当前进程的p_cpu
3. 每60次脉冲将每个p_cpu减去一个魔数
4. 范围在0-1024

### p_pri

1. 利用p_cpu计算
2. 只会在三个时刻利用p_cpu计算：
   1. 每60个脉冲对p_cpu>PUSER的进程重新计算
   2. 每60个脉冲对当前进程重新计算
   3. Trap末尾对当前进程重新计算
3. 会在下列时刻赋予特殊值
   1. 因使用外设睡眠时
      1. 高优先权赋予p_pri范围[-100,0)内的值
      2. 底优先权赋予p_pri范围[0,100)内的值
   2. 调用Sleep睡眠，置为90
   3. 新进程赋予p_pri为0
   4. wait系统调用将进程p_pri置为40

### 调用Swtch

可能会在以下时机调用Swtch

1. 中断
2. 系统调用（访问外设时，在Sleep函数中调用Swtch）
3. 例行调度
   1. 需要先前态为用户态
   2. RunRun!=0
      1. SetPri函数体内若新pri>现运行进程上台时的优先数Curpri，则更新RunRun
      2. WakeUpAll中，若被唤醒进程p_pri<Curpri，则更新RunRun

### 选新进程

1. 将RunRun置为0
2. 从**上次查找到的进程的后一个位置开始线性扫描**，找图像在内存的优先级最高的就绪进程。

## 结构体定义

![alt text](image-2.png)

### Process类

Process类常驻内存，其中保存的变量是无论进程是否在内存中，都有可能要访问的。例如进程的状态。

重要成员有：

1. p_addr
2. p_textp
3. p_state
4. p_flag
5. p_cpu
6. p_pri
7. p_wchan

### Text类

重要成员有：

1. x_daddr
2. x_caddr
3. x_size
4. x_count
5. x_ccount

### User类

重要成员有：

1. u_rsav
2. u_procp
3. u_MemoryDescriptor
4. u_ar0
5. u_arg

### ProcessManager

重要成员有

1. process[]
2. text[]
3. CurPri
4. RunRun

## 内核态函数

### Swtch函数

Swtch函数负责进程调度，有以下步骤：

1. 保存现场：
   1. 将esp，ebp保存至u_rsav中
2. 将运行进程改为0#进程
   1. 为0#进程创建核心态页表
   2. 用0#进程的u_rsav数组恢复esp和ebp
3. 选新进程
4. 将现运行进程改为新进程
   1. 为新进程建立核心态页表
   2. 用新进程的u_rsav数组恢复esp和ebp

在这一过程中EIP不变，所以三个进程共享同一段Swtch代码

### Sleep

用于让进程睡眠，接收参数为睡眠原因和睡眠时的优先数

1. 若优先数>=0
   1. 关中断
   2. 将状态更改为高优先数睡眠
   3. 设置睡眠原因
   4. 设置优先数
   5. 开中断
   6. 调用Swtch

### SetPri

负责重算p_pri，并设置RunRun，流程如下

1. 计算p_pri
2. 如果新p_pri大于现运行进程占用CPU时的优先数，更新RunRun
   1. 这使得每秒钟RunRun必定会被更新
   2. Trap函数末尾RunRun一定会被更新

调用SetPri的时机有三处：

1. 每60次心跳，对所有优先数大于PUSER的使用setpri
2. 每60次心跳处理末尾调用对当前进程调用setpri
3. Trap末尾

之所以设置当新p_pri大于现运行进程占用CPU时的优先数，更新RunRun，是因为在上述三个时机分别能起到下述作用：

1. 每60次心跳后必会设置RunRun，使得后续使用Swtch进行调度
2. 由于每60次心跳之后的处理时间较长，额外重新计算当前进程的p_pri，由于RunRun在之前已经更新了，所以并没有用
3. 将核心态的优先数更新为用户态的优先数，并更新RunRun

### WakeUpAll

用于唤醒由于指定原因睡眠的进程，所需参数为睡眠原因。流程如下

1. 遍历所有PCB
2. 判断是否由于指定原因睡眠
   1. 是则调用SetRun唤醒

### SetRun

流程如下：

1. 清除睡眠原因
2. 修改状态，**不改变优先数**
3. 如果被唤醒进程优先级高于现运行进程，设置RunRun

### Sys_fork

用于创建新进程。调用NewProc。对于父进程，返回值为子进程的pid；对于子进程，返回值为0。

### NewProc

NewProc用于创建新进程，流程如下：

1. 父进程esp,ebp保存至u_rsav中
2. 为子进程申请复制虚页表
3. 若内存分配成功
   1. 子进程复制父进程图像，子进程的p_addr指向该内存
   2. return 0

注意这里是c语言调用c语言

子进程后续会被Swtch调度，Swtch除了恢复esp，ebp外，还会return 0。虽然子进程一开始的核心栈顶端是NewProc的栈帧，但是EIP指向的是Swtch的代码。当执行return 1时，会视为NewProc的返回值，并撤销NewProc的栈帧，同时弹出的返回地址是NewProc之后的地址。