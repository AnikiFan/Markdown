# 计算机组成原理

## 计算机系统概论

### 计算机的诞生和发展

1. 第一台计算机：ENIAC
2. 冯诺依曼计算机特点：
   1. 由运算器、存储器、控制器、输入设备、输出设备组成。
   2. 采用存储程序的方式（基本特点），程序和数据存储在同意存储器中，用二进制码表示
   3. 指令由操作码和地址码组成
   4. 指令在存储器中按顺序存放，由PC指出要执行的指令所在的存储单元地址，一般按顺序递增，但是可以按运算结果或外界条件改变
   5. 以运算器为中心（现在是以存储器为中心）（控制流驱动方式），输入输出设备与存储器之间的数据传送都通过运算器
3. 计算器发展阶段：
   1. 电子管计算机
   2. 晶体管计算机
   3. 集成电路计算机——计算机普及应用
   4. 大规模集成电路计算机——RISC、小型机
   5. 超大规模集成电路
4. 软件与硬件在逻辑上等效，但是不等价

### 计算机的硬件

1. 指令：操作码+地址码
2. 计算机的基本部件：中央处理器（CPU：运算器和控制器）、存储器（主存和辅存）和输入输出设备
   1. 正在运行的程序和数据存放在主存中
   2. 运算器执行算术运算和逻辑运算
   3. 控制器实现程序的自动执行
3. 总线分为：数据总线、地址总线、控制总线
   1. CPU只发送地址
   2. 存储器只接受地址
   3. 输入输出设备既可以发送地址，也可以接受地址
   4. 所有部件均可以发送和接受数据和控制命令
4. 计算机系统的层次结构：
   1. 应用程序级（高级语言）（虚拟机器）
   2. 中间件/平台级（汇编语言或中间语言）（虚拟机器）
   3. 操作系统级（系统语言）（虚拟机器）
   4. 硬件（机器语言）（实际机器）
5. 翻译程序：
   1. 编译程序——若有修改，要重新编译
   2. 解释程序——每个语句都要重新翻译

## 计算机的逻辑部件

### 加法器

1. 超前进位思想：让高位的进位与低位无关，仅与两个参加的操作数有关
2. 组内超前进位：
   1. $X_iY_i$为生成进位单元
   2. $X_i+Y_i$为传递进位单元，可以将前一位中的进位传递到该位
3. 组间超前进位：
   1. 类似地，定义生成进位单元和传递进位单元
   2. 首先可以计算出第一组中的组合进位，以及各组的生成进位和传递进位单元
   3. 然后可以计算出组件进位信号，这里第二组的进位信号并不是由第一组的组内计算得到的（此时第一组的结果应该可以算出来了）
   4. 然后算出各组内的进位
   5. 算出最终结果

## 运算方法和运算部件

### 数制

常用的数制有：十进制，二进制，八进制和十六进制。

常用的转换方式有：

1. 十进制转二进制：整数部分采用逆向取余数的方式，小数部分则是每次乘2按顺序取个位。计算小数部分时，可能会出现无限循环，假设以及按照该方法取出了k位小数，那么这k位就已经确定下来了，且是准确的，误差只可能发生在k+1位小数及以后，所以误差小于$2^{-k}$。
2. 二进制转十进制：采用加权展开的方式
3. 二进制与八进制或十六进制之间的转换：一位八进制数对应3位二进制数；一位十六进制数对应4位二进制数。在转换时，按需在前端或末端添加0，转换结束后删去前端或后端的0。

### 编码

在计算机中存储的数据对应着某个数，我们将这个数成为“真值”，在这里我们规定真值必须要有正负之分。特别地，我们要考虑“正零”和“负零”。

#### 十进制数的编码与运算

计算机中的数据都以二进制存储，只由01组成。所以如果想要在计算机中直接存储十进制数，需要以编码的方式，也就是用特定的二进制组合来表示一个十进制数。

表示方案主要可以分为有权码和无权码

##### 有权码

在这类方案中，每个位置上的01值都对应这十进制中的某个值，称为权重，将每一位1所对应的权重相加，便可以得到整个组合所代表的十进制数。

常用的有权码是BCD码，也称8421码，因为该码共4位，从左到右对应的权重为8，4，2，1。也就是该编码方式和十进制数转换为2进制后的表示方式一致。

但是这种编码方式只考虑了0-9，使得当两个编码进行相加时，如果某位上的和大于9，则需要在该位上在加上6，也就是BCD码0110，以产生正确的进位。

##### 无权码

余3码是在0-9的4位二进制表示的基础上加上0011，即3，得到的编码。在使用余3码进行加法运算时，如果没有产生进位，则需要在该位减去0011，使得该位
符合余3码的规则（+3+3-3=+3）；如果进位，则需要再加上0011，使得该位符合余3码的规则（+3+3-6+3=+3，进位扣除了6）.

格雷码的特点是任何两个响铃编码只有1个二进制位不同。

### 计算机中的二进制数据表示及运算

在机器中并没有正负号，只能用01来表示正负，不同的表示方法产生了不同的编码方式。我们称计算机中用01串来表示的带符号的二进制数为”机器数“。
对于同一个真值$X$，它所对应的机器数可以由原码，补码或反码来表示。

要注意的是，对于任意一个真值，它的机器数是由表示实际在计算机中存储的编码，以及编码规则所决定的，所以机器数可能会和真值有偏差。真值的取值范围是实数，而机器数的取值范围则是特定编码格式所能表示的有限多个数。

因此，虽然机器数仍是个二进制——有小数点、由01组成，但是我们其中的01与其代表数值，更多的是一种符号含义，例如，我们规定第一位是符号位，为1代表真值为正，否则为负。我们只是在转换和运算时将其视为二进制数值。

接下来定义的各种编码，实际上是定义了两个函数$f,g$：

给定真值 $X$，由 $f$转换为能在计算机中直接存储和运算的二进制数，这个二进制数就是机器数，$g$则负责将这个机器数转换为实际在计算机中存储的01串（例如去除小数点等）。

二进制数可以分为整数，定点小数（小数点前只有1位的小数），和浮点小数（小数点前位数不定的小数）。这几种类型有各自的编码，即使共用一套编码规则，
具体的转换函数也略有差别。

#### 定点小数编码

在定点小数编码中，机器数对应的机器数也是一个小数，且规定小数点前为符号位。

\[
[X]_{原} = \begin{cases}
X&，X为正\\
1-X&，X为负\\
\end{cases}    
\]
\[
[X]_{补} = \begin{cases}
X&，X为正\\
2+X \mod 2&，X为负\\
\end{cases}    
\]
$[Y]_{补}$形成$[-Y]_{补}$的方法是从左到右依次取反，直到最后一个1为止（不包括对最后一个1取反）。
\[
[X]_{反} = \begin{cases}
X&，X为正\\
2-2^{-n}+X &，X为负\\
\end{cases}    
\]
对于正真值，三种编码方式得到的机器数相同。对于负真值，首先我们容易得到原码的表示方式；我们在原码的基础上保持符号位不变，数值位取反即可得到反码；保持符号位不变，数值部分从左到右依次取反，直到最后一个1为止（不包括），即可得到补码。

原码和补码在运算时遵循模2，而反码运算时遵循模 $2-2^n$，其中 $n$为精度，也就是说，当最高位产生进位时，要在最低位加1.
反码之所以遵循模$2-2^n$，是因为在反码中，正零和负零分别为$0.00\cdots0,1.11\cdots1$，两者正好紧挨着，如果得到的结果正好是负零，那么习惯上我们把它调整为正零，相当于进行了模$2-2^n$操作，如果得到的结果最高位需要进位，那么由于即跨过了负零又跨过了正零，所以需要通过加$2^n$来补偿，这一点也可以通过模$2-2^n$操作来实现。

如果机器数数值部分有n位，则原码，补码，反码能表达的正真值范围均为 $[0,1-2^n]$。对于负真值范围，原码和反码为$[-(1-2^n),0]$，补码则是 $[-1,0]$。

这里说的运算的结果都是一种编码，例如原码和原码的运算结果是一个原码，需要经过转换才能得到真值，运算中的进位规则和正常的运算一致而已

#### 定点小数运算

补码运算的实际实现是利用加法器，相反数的补码是通过取反后送入加法器，并且进位置为1来实现的

#### 整数编码

对于有着 $n$位数值的真值，
\[
[X]_{原} = \begin{cases}
X&，X为正\\
2^n-X&，X为负\\
\end{cases}    
\]
\[
[X]_{补} = \begin{cases}
X&，X为正\\
2^{n+1}+X&，X为负\\
\end{cases}    
\]
\[
[X]_{反} = \begin{cases}
X&，X为正\\
2^{n+1}-1+X &，X为负\\
\end{cases}    
\]

#### 浮点数编码

浮点数编码中使用了一种特别的整数编码——移码，只需把补码的符号码取反即可得到。因此，当移码全为0时，其真值为最小负值。移码进行加减法运算时，需要对结果的符号为取反。

有
\[[X\pm Y]_{移}=[X]_{移}+[\pm Y]_{补}\]

#### 乘法

|方法|部分积|乘数|被乘数|符号|补充|
|---|---|---|---|---|---|
|原码一位乘法|双符号位|无符号位|计算部分和时视为正数，也就是符号位为00|最后根据被乘数和乘数的符号决定||
|补码一位乘法|双符号位，右移时为算数右移，也就是补符号位|无符号位，数值部分和对应补码相同|转换为补码形式，包括符号位！|根据竖式计算结果直接得出|最后根据Y的符号进行调整后，不移位|
|布斯算法|双符号位，算数右移|使用一位符号位，考虑正负！并在末尾添加一个零|补码形式|根据符号直接得出|最后一次不移位，也就是存放在乘数部分的乘积低位位数最多只有乘数的位数|

乘法只有当两个最小负数相乘时会溢出，例如-1乘-1

#### 除法

|方法|被除数或余数|除数|余数|商|符号|
|---|---|---|---|---|---|
|不恢复余数法|双符号位，左移补0，绝对值原码形式|补码形式|如果最后一次商为0，则不左移并加上$[Y]_补$|从上到下，第一位为符号位，但是实际的符号直接根据除数和被除数的符号决定|直接决定|

当除数的绝对值小于被除数时，会产生溢出。

#### 浮点数

这里讨论的浮点数如果没有特别说明的话，不遵循IEEE754。

十进制数转换为浮点数时

1. 将十进制写为$0.x\cdots x\times D^d$的形式，其中 $D$为底，常取2，8或16
2. 将阶码$d$转换为要求的编码，注意，始终是01串
3. 将尾数$0.x\cdots x$转换为要求的编码，如果位数过长，则按照规定进行舍入

浮点数进行加减法时：

1. 通过减法比较两个阶码的大小。两个浮点数的编码格式应该相同，这里比较的本质上是阶码真值的大小关系，也就是 
\[X_{阶码}-Y_{阶码}\]
由于当两个真值的编码格式相同时，我们可以直接通过编码的运算结果——相同编码格式的一个编码，来得到实际真值的运算结果。实际上，我们这里便是通过编码的运算结果，以及那个编码的具体规则来判断那个阶码的真值更大。
2. 增加较小的阶码，同时右移对应的尾数，使得真值不发生变化（尽管可能会因为移位导致末尾被舍弃）
3. 尾数进行加减运算，运用双符号位
4. 调整尾数，使得双符号位相同，且与数值最高位不同。同时对应调整阶码
5. 舍入，调整时可能会导致还需要再次进行第4步，不断进行，直到不需要为止
6. 检查阶码是否溢出，在上述各步的过程中也要检查，如果出现溢出，则停止运算

其中，阶码常用移码来编码（移码只能编码整数），遵循以下运算规则：
\[[X\pm Y]_{移}=[X]_{移}\pm[Y]_{补}\]
使用单符号位时，移码与补码的转换只需要对符号位取反。

当使用双符号位时，第一位符号位正常时始终为0，第二位与使用单符号位时保持一致。当第一位变为1时，说明产生溢出，此时如果第二位为0，则表示上溢，否则为下溢。

阶码之间运算时，转化为阶码和补码之间的运算。此时如果阶码为负数，则双符号位为01，如果补码为负数，则双符号位为11。只要运算完后最左侧符号位为0便没有溢出，即使该位产生了进位

当基数为8或16时，尾数必须3位或4位一移，同时第四步的标准变为只需数值部分前3、4位中有一位和符号位不同即可。

### 校验码

#### 码距

为了实现校验功能，势必要有一部分信息传递能力要用于存储用于判断是否发生错误的信息。也就是说，有一些编码组合是非法的。我们定义任意两个合法的编码的二进制差异的位数的最小值为码距。当出错的位数小于码距时才有可能被检测出来，若大于等于码距，则出错的码可能会变为一个合法的码，但这实际上仍是一个错误。

#### 奇偶校验码

奇偶校验码的码距为2，只能发现奇数位错误，且无法进行定位。

实现的方式是在一段数据后加一个二进制位来使得整个01串满足特定的奇偶性。对于奇校验，补充的那一位二进制会使得1的个数为奇数，所以可以通过判断已有数据中是否有偶数个1来判断该位为1还是0。类似地有偶校验。

当我们接收到奇偶校验码后，可以根据1的个数以及其是奇校验还是偶校验来判断错误是否发生。

#### 海明码

海明码设有$r$位校验位，假设有$k$位数据，如果想要能够纠正数据的一位错，那么这$r$位校验位所能够表示的$2^r$个信息需要包含$k$位各位是否有错，$r$位校验码自身是否有错，以及是否没有错误这$k+r+1$个信息，所以需要满足关系式
\[2^r\geq k+r+1\]

如果想要能够自动校正一位错，并发现两位错，那么在$r$位校验位中，有一位负责表示出错个数的奇偶性，其余位数中的信息仍需包含这$k+r$位的各位是否有错。从而有
\[2^{r-1}\geq k+r\]

## 主存储器

### 主存储器分类、技术标准和基本操作

#### 分类

1. 随机存储器RAM
   1. 断电时造成信息丢失
   2. 访问时间与存储单元地址无关
   3. 静态存储器SRAM
      1. MOS管
      2. 矩阵结构
      3. 功耗大、集成度低、速度快
      4. 无需刷新
   4. 动态存储器DRAM
      1. 单MOS管
      2. 功耗小、集成度高、速度较慢
      3. 需要定期刷新
      4. 读出数据时会自动恢复
      5. 每一列都有自己的读出放大器，只需轮流改变行地址，对每一行的单元同时读出，就可以完成对整个存储器的再生
2. 非易失性存储器
   1. 断电时能保存信息
   2. PROM：一次性写入
   3. EPROM：能多次修改
   4. E$^2$PROM：修改次数有限
   5. Flash：大容量、低价、可改写、高速

#### 技术标准

1. 主存容量
2. 存储器存取时间
   1. 启动一次存储器操作（读/写）到完成该操作的时间
3. 存储周期
   1. 连续启动两次独立的存储器操作所需间隔的最小时间，通常略大于存取时间

#### 基本操作

CPU与主存之间采用异步工作方式，以ready信号表示一次访存操作的结束。

### 存储器的组成与控制

#### 存储器容量扩展

1. 位扩展：通过地址线并联芯片扩展字长
2. 字扩展：通过片选信号扩展地址

#### 刷新逻辑

1. 每次再生一行
2. 从上一次对整个存储器刷新开始，到本次对整个存储器刷新开始之间的时间间隔称为再生周期（刷新周期）
3. 异步式刷新：$t=T/n$，其中$T$是刷新周期，$n$为行数
4. 分散式刷新：将一个存储系统周期一分为二，一半用于刷新一行，另一般用于正常执行读写操作，从而$n$个存储系统周期后边刷新了一遍
5. 集中式刷新：在一个刷新周期内，利用一段连续的时间，对所有行逐一再生，在此期间停止对存储器的读和写。因为刷新期间不能访问存储器，有时会影响计算机系统的正确工作

#### 存储校验线路

一般在主存储器中设置差错校验线路，实现差错检测和差错矫正，代价式信息冗余。

#### 多存储体存储器

多体交叉存储器可以实现重叠与交叉存储。

每个存储体有独立的AR和DR

按低位地址划分

它利用的是程序段和数据段常连续地在主存中存放和读取这一假设。若遇到程序转移或随机访问少量数据，则该假设不成立，会产生存储器冲突，而降低了使用率。

按低位地址划分存在问题：

1. 模块数必须是2的幂次方，否则会导致地址不连续
2. 任一模块失效会导致地址空间的缺陷，而导致整个程序无法运行
3. 不利于存储器模块数的增量式扩展

多体存储器有两种不同的方式进行访问：

1. $M$个模块按一定顺序轮流启动各自的访问周期，启动两个相邻模块的最小时间间隔为单模块访问周期的$1/M$.（按低位划分）
2. 所有模块同时启动一次存储周期，相对各自的数据寄存器并行地读或写入信息（位扩展）。

## 指令系统

1. 指令是指挥机器完成某种操作的命令
2. 指令系统是某计算机能够直接识别、正确执行的所有指令的集合，是计算机软件与硬件的界面
3. 程序是若干条指令的有序集合
4. 评价标准：
   1. 有效性（速度）
   2. 规整性（格式统一）
   3. 对称性（对所有存储器单元和寄存器同等对待）
   4. 均称性（支持各种数据类型）
   5. 与数据格式的一致性：指令长度与数据长度相关

### 指令系统的发展

1. 早期，指令系统简单，寻址方式简单
2. 中期，指令系统丰富，寻址方式多样化
3. 如今指令系统的改进围绕缩小指令与高级语言的语义以及有利于操作系统的优化而进行。例如，对于科学计算机，提供浮点运算指令能显著提高运算速度。

### 指令格式

1. 计算机指令分为：
   1. 微指令：用于产生控制信号，最底层
   2. 宏指令：若干条机器命令组成的软件指令
   3. 机器指令：介于微指令与宏指令，每一条指令可完成一个独立的操作（本节中的指令都是机器指令）
2. 计算机语言分为：
   1. 高级语言
      1. 与具体机器的指令系统无关，面向算法
   2. 低级语言
      1. 机器语言（二进制语言）
      2. 汇编语言（符号语言）
      3. 和具体机器的指令系统密切相关
3. 指令按照作用可以分为：
   1. 动作类
      1. 传送类
      2. 运算类
      3. I/O指令
   2. 控制类
      1. 循环指令
      2. 移位指令
      3. 停机指令
4. 完备的指令系统应该包括：
   1. 数据传送指令
   2. 算术、逻辑运算指令
   3. 程序控制指令
   4. 输入/输出指令
5. 一条指令通常含有
   1. 操作码（$n$位能够描述至多$2^n$种操作）
      1. 固定长度，连续：便于译码，扩展性差
      2. 变长，分散于指令字中：能缩短指令的平均长度，用于字长较短的微型机
   2. 操作数地址（存储器地址、寄存器地址或直接给出操作数）
   3. 操作结果存储地址
   4. 下一条指令的地址（仅当改变程序的运行顺序，例如转移、调用子程序时才由指令给出）
6. 按照地址码个数可以分为：
   1. 零地址指令
      1. 无需任何操作数，如空操作指令、停机指令
      2. 操作数地址默认，如堆栈，或默认的寄存器
   2. 一地址指令
      1. 给出的地址既是操作数的地址，又是操作结果的存储地址
      2. 可能由另外一个操作数存储在默认的寄存器中
   3. 二地址指令
      1. 指出两个源操作数地址，其中一个还用于存放结果
   4. 三地址格式
      1. 两个地址用于指出源操作数地址，另一个是目的地址
7. 表示一条指令的机器字，就称为指令字
8. 数据字长决定了计算机的运算精度和寻址能力
9.  指令和数据都按二进制存储，但是指令的地址由PC给出，数据的地址由指令给出
10. 按照操作数类型可以分为：
   1. 存储器型指令
   2. 寄存器型指令
   3. 寄存器-存储器型指令
11. 指令长度应满足：
   1. 尽可能短（若可边长，则让指令长度与使用频率负相关）
   2. 是字符长度的整数倍
   3. 操作码字段足够表示指令系统的全部操作
   4. 地址段位数足够长

### 寻址方式

1. 直接寻址
2. 寄存器寻址
   1. 地址码短
   2. 存储速度快
   3. 可以缩短指令长度，节省存储空间，提高执行速度
3. 基址寻址
   1. 地址码称为位移量
   2. 有效地址为基址寄存器内容加上位移量
   3. 用于扩展寻址范围，可以将地址分为多段，段首地址存储在基址存储器中，段内位移量由地址码给出
4. 变址寻址
   1. 通过改变变址寄存器的值实现循环操作
   2. 如果计算机中还有基址寄存器，计算有效地址时要加上基址寄存器
5. 间接寻址
   1. 寄存器间接寻址
   2. 存储器间接寻址
6. 相对寻址
   1. 用于转移指令
   2. 转移到（PC）+Disp
7. 立即数寻址
   1. 减少访问存储器的次数
   2. 提高执行速度
   3. 常用于给寄存器或存储器单元赋初值
8. 堆栈寻址

### 指令类型

1. 算术逻辑运算指令
   1. 根据结果更新状态位Z（结果为0），N（结果为负），V（结果溢出），C（产生进位或进位），其中NV根据带符号数的运算结果更新，C根据无符号数结果更新
2. 位移操作指令
   1. 算术位移
   2. 逻辑位移
   3. 循环位移
      1. 小循环
      2. 大循环
   4. 转移指令
      1. 无条件转移指令（jump）
      2. 条件转移指令（branch）：
         1. 根据由ZNVC，P（若为偶标志位，当有奇数个1时，置1）
      3. 调用指令（call）：要将寄存器内容保存在堆栈中
      4. 返回指令（return）：要从堆栈中堆栈中恢复寄存器内容
      5. 陷阱指令
   5. 堆栈指令：
      1. 压入时，先减少SP值，减少量为压入数据的字节数，然后再压入数据
      2. 弹出时，先读出数据，然后增加SP值
      3. 还可以用于传参

### 指令系统优化

1. 霍夫曼编码：
   1. 按出现概率递增从左到右排序
   2. 向左下降赋1，向右赋0
   3. 理想长度为$-\sump_i\logp_i$
2. 缩短地址码长度（增加寻址空间）方法：
   1. 间接寻址（存储器间接寻址要访存两次，速度慢）
   2. 变址寻址
   3. 寄存器间接寻址
3. 地址吗个数选取标准：
   1. 程序存储量
   2. 程序执行速度

### CISC

1. 指令系统庞大
2. 指令功能复杂
3. 指令格式、寻址方式多
4. 大多数指令需多个机器周期
5. 各种指令可以访存
6. 采用微程序控制
7. 少量专用寄存器
8. 较难优化编译系统
9. 指令使用频率相差大

### RISC

1. 指令系统小
2. 指令格式少
3. 寻址方式少
4. 大多数指令在一个机器周期内完成
5. 通用寄存器数量多
6. 只有Load/Store指令可以放存
7. 以硬布线控制器为主
8. 较容易优化编译系统
9. 指令使用频率相差不大

## 存储系统

### 存储系统的层次结构

1. 一般用DRAM作为主存储器，用磁盘、磁带和光盘作为外存储器
2. DRAM可以随机访问任一单元
3. 辅存一般为串行访问存储器，读写是需要顺序地一位一位地进行，访问指定信息与信息所在位置相关
4. 串行存储器分为顺序存取存储器（磁带）、直接存取存储器（磁盘）
5. 操作系统和硬件结合，把主存和辅存统一成了一个整体，形成了一个存储层次。
   1. 速度接近于主存
   2. 容量接近于辅存
   3. 如今称为虚拟存储系统
   4. 程序员可以用机器指令地址码对整个程序统一编址
   5. 该空间比实际空间大得多，地址码称为虚地址或逻辑地址，容量称为虚存容量
   6. 实际主存的地址称为物理地址或实存地址，对应容量为主存容量
   7. 使用虚地址访问主存时，会先经过软件和硬件变换为主存实地址，查看这个地址对应的内容是否装入主存，如果装入，就访问，否则，经过软件和硬件把对应的程序或数据调入主存
   8. 上述内容无需程序员参与
   9. 主存-辅存层次满足了存储器大容量和低成本需求
6. CPU和主存之间设置高速缓冲存储器（cache），要求cache在速度上能跟得上CPU的要求。该层次完全由硬件实现
   1. 速度接近于cache
   2. 容量与每位价格接近于主存
   3. 解决了速度与成本之间的矛盾

### cache

1. 程序访问局部性（局部性原理）
   1. 访问的逻辑地址集中在小范围内
   2. 程序地址分布连续
   3. 循环程序、子程序重复执行
   4. 数组访问地址集中
   5. 可以选择地址集中的工作单元
2. cache一般由SRAM组成
3. 读方式：
   1. 先读到cache，再给CPU
   2. 通过式读：一边读给cache，一边给CPU
4. 写方式：
   1. 写回法：设置标志位
   2. 通过式写：既给cache写，也给主存写

## 输入输出系统

1. 每台设备由地址码，称为设备代码
2. 寻址方式：
   1. 专设I/O指令，地址码字段指出设备代码
   2. 利用访存指令完成I/O
3. 设备控制器即I/O接口：
   1. 实现主机和外部设备之间的数据传送
      1. 同步控制
      2. 设备选择
      3. 数据传达
      4. 中断控制
   2. 数据缓冲，设有数据缓冲寄存器
   3. 接受主机命令，提供设备接口状态，按照主机命令控制设备
4. 输入输出接口类型按照数据传送宽度可以分为：
   1. 并行接口
   2. 串行接口
5. 输入输出接口类型按照数据传送方式可以分为：
   1. 程序控制输入输出接口
   2. 程序中断输入输出接口
   3. DMA接口

### 程序直接控制方式

1. 传送时
   1. CPU启动设备
   2. 发出启动命令
   3. CPU等待外部设备完成准备工作
      1. 等待期间不断发送测试指令
      2. 等待期间CPU不发进行其他工作
   4. 测试到标志触发器置“完成”
   5. 进行数据传送
2. CPU与设备只能串行工作，系统效率大大降低

### 程序中断传送方式

1. 传送时
   1. 在程序中安排一条指令
   2. CPU发出信号启动外部设备
   3. CPU继续执行原程序
   4. 外部设备做好数据传送的准备后，向CPU发出中断请求
   5. CPU停止正在运行的程序，执行“中断服务程序”
   6. 完成传送，通常为一个字或一个字节
   7. 返回原来的程序
2. 能够实现CPU和外部设备的并行工作

#### 中断

1. 中断的作用
   1. CPU与I/O并行工作
   2. 硬件故障处理
   3. 实现人机联系
   4. 实现多道程序和分时操作
   5. 实现实时处理
   6. 实现应用程序和操作系统的联系
   7. 多处理机系统各处理机间的联系
2. 中断源，即发出中断请求的来源
   1. I/O设备等处理机外部设备的中断，外中断
   2. 处理器硬件故障，或程序出错，内中断
   3. Trap指令的软中断
   4. 外中断和内中断都是随机发生的，而软中断是预先安排的
3. 中断触发器/中断寄存器
   1. 记录中断源的是否产生中断
   2. 负责向CPU发出“中断请求”信号 
4. 禁止中断
   1. 禁止CPU处理中断
5. 中断屏蔽
   1. 屏蔽部分中断
6. 中断处理流程
   1. 关中断
   2. 保存断点（PC），保存现场（寄存器）
   3. 判断中断源，转向对应的中断服务程序
      1. 查询法：查询中断触发器
      2. 串行排队链法
   4. 开中断
   5. 执行中断服务程序
   6. 关中断
   7. 恢复现场，恢复断点
7. 多重中断处理：
   1. 子啊某个中断过程中由发生了新的中断请求，从而中断该服务程序的执行，又转去新的中断处理
8. 处理优先级考虑因素
   1. 中断的紧迫性
   2. 设备的工作速度
   3. 数据恢复的难易性
   4. 要求CPU提供的服务量

### 直接存储器存取方式（DMA）

1. 在外部设备和主存之间开辟直接的数据传送通路
2. 当外部设备完成准备工作后
3. 占用总线一个工作周期，和主存直接交换数据
4. 不足之处
   1. CPU承担对外部设备的管理和某些操作的控制
   2. 多个DMA会引起访问内存的冲突
5. DMA的数据传送由硬件完成
6. DMA所需控制信息由CPU以程序的方式送入
7. DMA与CPU同时访问内存时，赋予DMA较高优先级
8. 与中断的区别：
   1. 中断的输入输出依靠CPU的输入输出指令，DMA靠硬件来完成
   2. 中断要保存现场，恢复现场，DMA不要
   3. 中断可以处理各种任务，DMA只负责数据传送
   4. 中断响应发生在一条指令执行结束后，DMA可以在两个存储周期内响应
9. 工作方式
   1. 让CPU暂停，让出存储总线
      1. 一般在接口设有小容量存储器，减少DMA占用总线时间，即CPU停止工作时间
   2. CPU周期窃取
      1. 让CPU暂停一个CPU周期
   3. 直接访问存储器工作方式
      1. 标准方式
      2. 若传送时CPU不占用存储总线，则对CPU不产生任何影响
      3. 若CPU占用存储总线，则DMA优先级更高
      4. DMA传送数据过程中，不能占用或破坏CPU硬件资源或工作状态
10. 基本组成：
    1. 设备寄存器
       1. 主存设备寄存器
          1. 主存缓冲区首地址
          2. 传送前传入
       2. 外围设备地址寄存器
          1. 存放I/O设备设备码，或寻址信息
       3. 字数计数器
          1. 对传送数据总字数进行统计
       4. 控制与状态寄存器
       5. 数据缓冲寄存器
    2. 中断控制逻辑：
       1. 负责CPU对DMA进行预处理和后处理
    3. DMA控制逻辑
       1. 设备码选择电路
       2. DMA优先排队电路
       3. 产生DMA请求电路
       4. 控制数据传送
    4. DMA接口与主机和I/O设备两个方向的数据线、地址线和控制信号线以及有关收发与驱动线路
11. DMA预处理
    1. 外围设备寻址信息
    2. 传送数据字数
    3. 内存缓冲区首地址
    4. 启动DMA，对状态寄存器置位
12. 输入循环
    1. 读数据到数据缓冲寄存器
    2. 送数据到数据总线
    3. 将主存缓冲首地址送到地址总线
    4. 写数据
    5. 主存缓冲首地址+1
    6. 字数计数器-1
    7. 若字数计数器为0，则产生中断，通知CPU传送完毕
13. 输出循环
    1. 送地址
    2. 读数据到DBR
    3. 写数据到输入输出设备
    4. 更新地址
    5. 字数计数器-1
    6. 若字数计数器为0，则产生中断，通知CPU传送完毕

### I/O通道控制

1. 专用设备
2. 独立执行通道命令编写的输入输出控制程序
3. 产生控制星号送给它管辖的设备控制器
4. 减轻CPU负担
5. 不是完全独立，例如码制转换、数据块的错误检测与矫正，需要由CPU完成
6. 应具有以下功能：
   1. 选择某一指定外设与系统相连
   2. 向外设发出操作命令，并初始化
   3. 指出主存缓冲区地址
   4. 完成数据字的分拆与装配
   5. 检查外设状态
7. 与DMA的区别：
   1. DMA完全借助硬件，通道通过通道命令与硬件一起完成
   2. DMA只能用于告诉设备，通道可以用于高中低速设备
   3. DMA只能连接一台设备，一个通道能连接多台
8. 通道种类
   1. 字节多路通道：
      1. 以字节为单位轮流向多个设备进行数据传输
      2. 多个设备同时处于工作状态
      3. 能交叉数据传输
      4. 传输率是各外部设备传输率之和
      5. 适合中低速设备
   2. 数组多路通道
      1. 以固定大小的数据块为单位，选择传输的外部设备
      2. 多个设备可以同时处于工作状态，当一个设备传输完一个数据块后，就换另外一台外部设备
      3. 最大传输率是各外部设备传输率中最大的
   3. 选择通道
      1. 适合高速块设备
      2. 可以多个不同外部设备进行控制
      3. 但一次只有一个外部设备工作

### 外围机处理方式

1. 可以完成I/O通道的所有功能，同时可以完成码制转换等功能
2. 独立于主机工作

## 总线

1. 总线类型：
   1. 单总线
   2. 多总线
      1. 将速度较低的I/O分出去
2. 也可以分为：
   1. 连接计算机内部各模块的总线
   2. 系统之间或系统与外部设备之间的总线
3. 总线控制线路包括：
   1. 总线判优
   2. 驱动器
   3. 中断逻辑
4. 可以控制总线并启动数据传送的设备称为主控器或主设备，能够响应总线主控器的设备称为受控器或从设备
5. 总线判优控制分为
   1. 集中式控制
      1. 链式查询方式
         1. 距离总线控制器近的更优先
         2. 连接简单，扩展设备容易
         3. 对电路故障敏感
         4. 优先级固定
      2. 计数器定时查询方式
         1. 可以更改部件的优先级
   2. 分布式控制

## 备考

### 刷新

因为DRAM在保持状态下，MOS管会漏电，所以要隔一段时间便刷新。

DRAM在读出时便完成刷新，但是没法保证所有单元都得到刷新，所以需要安排刷新逻辑。

三种刷新方法：

1. 集中刷新：
   1. 在一个刷新周期内（连续两次完整刷新的间隔），利用一段固定的时间，依次对存储器的所有*行*逐一刷新，在此期间停止读写
   2. 刷新期间无法访问存储器
   3. 影响正常工作
2. 分布式刷新：
   1. 把对各行的刷新分散到各个工作周期中。把一个存储器的系统工作周期分为两部分，一部分用于正常读、写或保持；另一部分用于刷新某行
   2. 增加了系统的存取周期
   3. 没有死时间
3. 异步刷新：
   1. 将刷新周期除以行数得到两次刷新之间的时间间隔，利用逻辑电路没隔时间$t$产生一次刷新请求
   2. 减少刷新次数
   3. 避免CPU等待时间过长

### 读、写周期

1. WE期间地址不能发生变化

选择题25题，一题一分，单选题；

填空题，15空，一空一分；
简答题，6题，每题5分；
分析题，3题，每题10分，5，6，7章。

完全不涉及章节：
第8章，第9章，第11章，第12章。

简答题、填选：

1.2，1.3不涉及简答题

掌握说明要简答
熟悉只有填选

第二章 掌握加法器

第3章

其他都是熟悉
掌握校验码

第4章

设计到电子元件的地方不考，像静态电路的原理

读写，读周期，写周期掌握

动态存储器的刷新有3种，都要掌握

第5章

整章都是重点，除了指令系统的发展

第6章

微程序的设计没有大题，但是有填选。

流水线要掌握。

第7章

7.1-7.4掌握

重点掌握7.1，7.2全部，7.3.1，7.3.2
cache的内容一定要掌握，以教材为准

页式存储全部搞清楚，TLB是静态的还是动态的，因为不经常刷新，所以要静态

7.4相联存储器的原理

第10章

掌握程序直接控制

中断，有简答，填选，重点

1. 7个作用
2. 3个条件
3. 执行过程
4. 判断中断源的方法
5. 找中断服务子程序的入口地址的方法
6. 中断大致分为5个阶段
7. DMA三种工作方式
8. 中断与DMA的异同
9. 三个影响中断响应时间因素
10. 四个中断优先级因素

不考外设接口

重点掌握总线的优先级。

1. 内部总线
2. 系统总线 
3. I/O总线

4. 集中式仲裁
   1. 链式查询方式
   2. 计数器定时查询
   3. 独立请求方式
5. 分布式仲裁

总线传送四阶段