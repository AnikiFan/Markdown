# 高程
## 第二章

**一定要一句一行**  
**鼓励复用函数**  
取反就是0，1互换  
~~原码换算为补码的逆运算是-1，取反,再变为相反数~~


以2字节-32768为例，先将其转换为其绝对值的二进制1后面在跟15个0,此时最前面的1代表着$2^{15}$也就是10进制里的32768,取反得到0后跟15个1,加一便得到1后面跟15个0,也就是原码中的-0  

要注意的时上面这个案例是极端的,在正数的原码中,第一位永远是0,而在负数的绝对值所对应的二进制中只有像上面的例子那样的极端情况才会在第一位出现1,只有此时绝对值的二进制和其原码不对应,是个特例,其他的时候绝对值的二进制表示和其原码都一样


- [x] 课后check一下


|原码|补码|
|--|--|
|-0|-32768|
|-1|-32767|
|...|...|
|-32767|-1|

负数的原码加补码等于-32768 即$-2^{15}$
计算机里对于整数的表达只有补码,没有原码
补码通过将正负0的补码统一成全都是0来消除0的二义性,也就是说它把原先的负0给消除了,这使得补码可以比原码多表示一个数,那就是-32768  
应该先去判断一个数是什么类型再去判断它的值
不同编译器的数据的长度可能不同

**对于整数型,必须占满对应字节长度**
输出的数字不会标注进制 

***每个文件都应该检查一遍配置属性 链接器 系统 子系统是否为控制台***
## 二进制与十进制小数之间的转换 

当遇到带有小数点的十进制时,并且想将其转换为二进制,对于其整数部分我们只需用常规的短除法来操作,对于其小数部分,我们将单独处理它.  
首先,写下0.xxx,其中xxx为小数点后的部分,然后我们将这个数字乘以2,取得到的数字的个位数
这个数字便是对应十进制的小数点后第一位,如果这个数字是1,那么我们在下一次操作时将这个一改为0,如果是0,那么保持不变,下一步操作是继续乘以2 ,当取了n个数后所得的数字小数点后都是0了,那么就停止操作,我们便得到了十进制下的小数.  

如果想要将二进制小数转换成为十进制小数,只需和整数部分一样采用加权展开即可.  


**要注意当把八进制或者十六进制转换为二进制时,转化的过程中间应该严格遵循1位对应3或者4位二进制,在写答句的时候可以省略最前面的0**

**需要记忆最基本的字符的ascii码**

***在正确情况下按最长原则来判别\代表什么字符 如\123应该理解为\123而不是\1和23或\12和3,对于\x而言,后面不能跟3位及以上的16进制,如fff,会报错,但是二位16进制后可以跟其他的非0-9,a-f的字,如空格***
*字符串结尾不能为\0*
c和c++中但有害和双引号有严格区别,一个是字符一个是字符串
\是转义符,\+一个字符将它转换为另外一个字符,也就是\+一个字符在内存中是另外一个字符,\不会出现在内存中
字符串的尾0的\0就是被转义到了另外一个字符,因此字符串在内存中的实际字符会多一个

***应该避免使用全文替换***

标识符长度意味着只会截取前面多少位字符,如果长度限制是2,那么对于abc和abd,两个都是合法的,但是计算机只会取前面两位即ab

dev中不支持用中文来当标识符,因此应该尽量不用
*禁用auto*
*42页第二个框中输出abc是什么,语句执行是从左到右,单个语句内部也是,a=b=c=10是先定义a并把b赋值给a,然后把c赋值给b,此时变量a,b实际上都是c的值,然后再把10赋值给c,这是abc应该都是10*

数据的溢出可以理解为65536进制(2字节)
以一字节signed char为例
|...|0111 1111|1000 0000|...|1111 1110|1111 1111|0000 0000|0000 0001|
|---|----|----|----|----|----|---|----|
|...|127|-128|...|-2|-1|0|1|
可以看出来二进制补码对应的十进制是一个循环,达到最大值127后的下一位便是最小值-128然后不断上升
当第一位为1时,补码对应的十进制是负数,其对应的数和正数一样位权展开,只不过此时的1和0颠倒且是从-1开始加的,即1000 0000=-1
同时也可以理解为以0000 0000=0为基准,然后位权展开,一直累加到127后下一位从-128开始,因此1111 1111是-1,这样来看的话,第一位在1,0之间变换时,会前进\后退128位,例如从0到-128,无论怎样0一定在这两个位置之间,因此两个位置对应的十进制的绝对值之和是128

对于同长度的signed与unsigned互相赋值时,两者对应的十进制的绝对值之和等于2^总位数,如char的话便是258
可以这样理解
|二进制|0000 0000|0000 0001|...|0111 1111|1000 0000|1000 0001|...|1111 1111|
|---|---|---|---|---|---|--|--|---|
|unsigned|0|1|...|127|128|129|...|257|
|signed|0|1|...|127|-128|-127|...|-1|
因此两者在对于首位为1的二进制的处理上发生了差异,在于两者对于128从那里开始不同
|-128|...|-1|0|1|...|127|128|...|257|
|--|--|--|--|--|--|--|--|--|--|
|signed起始处| | | | | | | unsigned起始处 |||
因此两者绝对值之和为258

47页unsign和sign的绝对值相加为65536,快速计算

strlen只能输入字符串而不能输入字符char,输出的是字符串中字符的个数,不包括尾零,而sizeof既可以输入字符也可以输入字符串,输出的是输入在内存中的字节,因此在输入字符串时会将尾零算入

|输出\输入|unsigned 短|signed 短|
|--|--|--|
|unsigned长|无影响|负数会改变|
|signed长|无影响|负数会改变|
### 符号常量
>可以理解为定义缩写
本质上就是定义了字符串a来代替某一字符串
\#define a b;
上面这行实际上就是把其下面的代码中的a全都换为了b;
本质就是文字替换
>

*整数相除\是直接舍去小数,整除%结果用竖式除法来解决*

### 栈的运算
加入栈的运算符应该是在之前的栈顶运算符之前或者同时生效的运算符,即和它等级相同且右结合(从右往左)或者比它运算等级高,若是之后生效的,即等级更低或者左结合(从左往右)

a
B  \\
对于这种与顺序相关的运算,正确的应该是B\A,即从下往上取,从左往右列
### 类型转换
short a=1 ,b=a+1得到的b是short
而short a=1,b=1,a+b是int
类型转换是按需转换,只有在必要的时候才会进行
float型转换为char\short\int等整数特有的类型时会忽视掉其小数,溢出的处理方法和长变短字节的处理相同,即直接切掉前面的
-[ ] 其他类型准换到float以及float支持的范围,搜索资料

### 自增与自减
当自增与自减位于前面作为前缀时,会直接将其后面的变量加一\减一,作为后缀时,vs会先将原值赋值到一个中间变量中,以它来代替原先的变量来接受其他运算,之后在把原变量加一,而dev则是相反,先将原变量加一,在将加一\减一之前的变量复制到中间变量来进行后续运算,区别在于前者的加一减一操作是在最后执行,而后者不是,从而有可能被后续操作覆盖
前缀效率更高,因为不会创建中间变量

## 程序编写细节处理

一个语句一行
变量名不要用中文
不要使用全文替换
vs中使用sin等数学公式时不需要cmath的头文件,但是如果要使用的话一定要加上去
推荐格式
``` c++
#include <iostream> 
#include <cmath> //数学函数对应头文件，VS可省略 
using namespace std; 
int main() 
{	double a = 0, b = 5.78 * 3.5, c = 2 * sin(2.0);
	cout << a << endl;
	cout << b << endl;
	cout << c << endl;
	return 0;
}
```