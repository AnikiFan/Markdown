# Database System Concept

## Relational Database Design Optimization

### 数据库优化目标

1. 避免冗余数据
2. 能够表示出属性之间存在着的关系
3. 有助于检验一致性约束

### 函数依赖

函数依赖实际上就是说一组属性到另一组属性之间存在一个函数关系（两组属性不一定互斥）。这一定义实际上是用于检验的，而并非用于判断的。也就是说，两组属性之间是否存在函数依赖通常是根据现实意义来直接判断出来的。

显然，当自变量对应的属性减少或因变量对应的属性增多时，函数依赖增强了，反之则减弱了。

当函数依赖$\alpha \rightarrow \beta$成立，且$\alpha$无法再缩小时，则称该$\beta$完全依赖于$\alpha$，否则称为部分依赖。

### 分解

一个大关系可以分解为若干个小关系，必要时再将他们连接起来，这些小关系的属性之间不必互斥。

如果采用自然连接后所得的关系和原关系完全相同，则称该分解为无损分解。

对于分解为两个关系的分解，如果得到的两个关系的属性的交集不为空时，该交集为至少为分解得到的一个关系的超码，则这个分解便是无损的。

对于分解为多个关系的分解，采用表格法来判断是否为无损分解。列为各个属性，行为分解得到的各个关系。一开始，将各个空格填上$a_{i,j}$，如果对于某个关系，给定函数依赖集在它上面的限制中的因变量中含有某属性，则将该位置改为$a_j$。然后遍历所给的函数依赖，如果某两行上的自变量对应着的属性相同，则将其因变量对应着的属性上的元素改为相同的，优先改为形如$a_i$的样式。遍历完所有函数依赖后，如果有一行上的元素都形如$a_i$，则说明该分解时无损分解。

### 函数依赖集

有三条公理可以用于从已知函数依赖中推导出新的函数依赖：

1. （自反律）$\beta\subseteq\alpha\Rightarrow\alpha\rightarrow\beta$
2. （增广律）$\alpha\rightarrow\beta\Rightarrow\gamma\alpha\rightarrow\gamma\beta$
3. （传递律）$\alpha\rightarrow\beta,\beta\rightarrow\gamma\Rightarrow\alpha\rightarrow\gamma$

可以证明，这具有Soundness and Completeness.

从一个函数依赖集$F$可以推导出来的所有函数依赖所组成的集合叫做原集合的闭包$F^{+}$。

只需要对于已经得到的函数依赖集中的每个函数依赖依次使用自反律和增广律，然后使用传递率，如此循环，知道无法得到新的函数依赖为止，我们便可以得到闭包。

### 属性集的闭包

对于一个指定的函数依赖集$\mathbf{\alpha}$，一个属性集的闭包$\mathbf{\alpha}^{+}$定义为可以用该函数依赖集推导出来的所有因变量所组成的集合。
\[\alpha\rightarrow\beta\in F^{+}\Leftrightarrow\beta\in\mathbf{\alpha}^{+}\]
想要求出一个属性集的闭包，只需维护一个属性集，其中的属性是可以依据所给$F$（而非$F^{+}$）直接得到的因变量，一开始包含$\mathbf{\alpha}$，随着不断更新而扩大，最终确定下来的集合便是所求的闭包。

### 正则覆盖

对于一个函数依赖集，我们称与之等价的、且无冗余属性和函数依赖的函数依赖集为它的正则覆盖。

对于一个函数依赖$\alpha\rightarrow\beta$，如果我们从$\alpha$中删去一个属性，我们得到的是一个更强的函数依赖，因此我们需要证明这实际上是可以从已知函数依赖集中推导出来的；如果我们删去$\beta$，我们得到的是一个更弱的函数依赖，因此我们需要证明采用这个函数依赖时，仍然可以推导出当前的函数依赖集

想要计算一个函数依赖集的闭包，我们首先需要将形如$\mathbf{\alpha}\rightarrow\mathbf{\beta_i}$的函数依赖合并为$\mathbf{\alpha}\rightarrow\prod_i\mathbf{\beta_i}$，然后验证是否能够进行上述化简，如此往复，知道确定为止，这样得到的集合便是闭包。

### 候选码

给定函数依赖集，和一个关系，可以将该关系中的各个属性按照是否只作为自变量、只作为因变量、既作为自变量又作为因变量、既不作为自变量又不作为因变量划分为4类，分别记为L、R、LR、N，将$L\cup N$记为$X$，如果$X$能够作为超码，那么$X$就是唯一的候选码，否则，遍历$LR$的一元子集，将其和$X$作并后判断是否为超码，如果是则记为一个候选码，如果在这一轮中没有找到任何一个候选码，则再次继续遍历$X$的二元子集，以此类推，知道找到候选码为止。

