# OOP

## 指针进阶

判断数据类型的方法是,从变量名处开始向外按照优先级进行解析,例如,和`()`先结合便是函数,
和`[]`先结合便是数组,和`*`先结合便是指针.

### 高维数组

&可以作用于数组名以及变量(包括指针变量),而不可以作用于一个地址.
假设定义`int test[10]`,则`test`是数组名,而`test+0,test+1,...`均为地址.
对于一个多元数组,假设是二维数组,我们可以把整个机器的内存地址视为第一层地址,
二维数组的行为第二层,列为第三层,,可以通过`&`来降低层数.
a+0,a+1,...是以行为单位,而&a,&a+1,..是以整个二维矩阵为单位.
高维矩阵应该视为一个元素为更低一维度的矩阵的矩阵名的一维矩阵.

也就是说,对于一个n维矩阵x.
&x是回到整个机器的内存这一层,&x+i是让指针以整个矩阵大小为单位在该层移动(这实际上是没有意义的);x+i则是在该矩阵中的第一维度移动,是以第二维度为单位,`*(x+i)`则是取该指针对应的地址中的值,由于我们是在矩阵内部操作的,我们所取到的是第二维度中该地址的值,实际上是一个数组名,等价的操作是x[i].特别地,*数组名等价于数组名[0],以及\*(数组名+0)
&x[i]是先将指针以下一层为单位移动到x+i,然后进入到下一层,取其中存储的数组名,
最后在通过&返回到原来的那一层

回到二维数组的例子,这里第二层被称为行地址,第三层被称为元素地址.

sizeof 中如果是数组名的话返回的是整个数组的大小,而如果是地址的话则是指针的大小

一个数组名作为指针时,其基类型为该数组的元素.

`int (*p)[4]`定义了一个指针,指向一个有着四个int的数组的数组名,p+i以这一整个数组为单位移动,
与一个二维数组相似.

`a[i]`与`*(a+i)`等价,而`&`与 `*`能抵消,因此a+1 等价于 &a[1]
a[1] 等价于 `*(a+1)`
&a[i] 与 a+i都是行地址
a[i]与`*(a+i)`都是元素地址
对行地址进行取值操作会得到元素地址
sizeof (*p)问的是基类型的大小

### 函数指针

#### 函数指针定义

`数据类型 (*指针变量名)(形参表)`

#### 函数指针的使用

赋初值: `指针变量名=函数名`,不要带参数表

调用: `指针变量名(函数实参列表)`

函数指针`p`与`*p`打印出来都是同一个地址,后者不常用.
函数名`fun`与`*fun`打印出来的也都是同一个指针,后者不常用.

### 指向类对象的成员函数的指针

#### 定义

`成员函数返回类型(类名称::*指针变量名)(形参表)`

#### 赋值 

`指针变量名=&类名称::函数名`

这里之所以要加`&`,可以理解为是为了抵消使用时前面加的`*`
所赋值的函数必须时`public`

#### 使用

`(对象名.*指针变量名)(实参表)`

前面加`*`是为了与其他普通成员区分开来

### 高维字符数组与字符指针数组

`char a[3][10]`本质上是二维数组

`char *s[3]`则是一个指针数组,里面的每个指针可以再对应一个一维的字符数组,也可以是一个无名字符串,如果对于存储的字符串没有改变的需求的话,推荐用第二种.如果用第二种的话应该要使用`const char *s[3]`

二维字符数组相比于一维指针数组的优势有：

1. 与无名字符串常量分占不同空间
2. 字符串的值可以修改

缺点有：

1. 有空间浪费
2. 若要交换元素，则需整体移动元素

一维数组指针相对于二维字符数组的优点有：

1. 节约空间
2. 交换时只需交换指针即可，效率高

缺点有：

1. 如果指针指向无名字符串常量，则无法改变字符串的值

### 指向指针的指针

#### 定义 

`数据类型**指针变量名`

### const 指针

为了避免通过指针来改变其所指变量的值,我们可以将指针的基类型前面或后面加上 `const`,使得指针所指的变量变为只读.

通常的变量既能读,也能写,可以赋值给只读的`const`变量,而反方向则不行,不能赋予另一个变量以自己没有的权限.实参与形参之间的赋值也遵循这种规律.

**但是你可以强制转换后再赋值，即便是const指针也能无报错转化为非const指针**

### 常指针

形式为`数据类型*const指针变量名`，特点为：

1. 可以通过执政修改变量的值，即有读写权限
2. 必须在定义时初始化，不能再指向其他同类型的变量
3. 适用于希望指针始终指向某个变量的情况

由于特点一，如果常指针的基类型不为常变量的话，它不能指向常变量。

指向常量的常指针形式为`const 数据类型 *const 指针变量名`，特点为

1. 只有读的权限
2. 必须在定义时初始化
3. 适用于即希望始终指向固定变量，又希望不能通过执政修改变量值的情况。

### void指针

含义为指向空类型的指针变量，其特点为：

1. 不能直接通过`void`指针访问数据（不知道基类型），必须强制转换为某种确定的数据类型后才能访问。
2. 非 `void`型的指针可以直接赋值给 `void`类型，`void`类型赋值给非`void`类型时必须强制转换。

### 空指针`NULL`

空指针允许有空值 `NULL`，表示不指向任何变量。系统的字符串操作函数若传入参数为 `NULL`则会报错。

### 引用

数组的引用`char(&s1)[list.length]`能够保留数组长度这一信息，与指针不一样。
但是这样的使用固定住了数组的长度，不太实用。
当然通过某些途径可以让数组长度可变。
与指针不同，引用数组时必须要大小一致。同时不能将一个指向数组的指针传给数组的引用，因为指针已经失去了长度信息。

需要注意的是，引用并不能完全替代指针。

定义结构体时，成员类型不能是其本身，但是可以是指向自己的指针，因为指针大小已知。

## 动态内存申请

### 链表和数组的比较

|数组|链表|
|--|--|
|大小在声明时定义|大小不固定|
|处理的数据个数有差异时，须按最大值声明|根据需要随时增加/减少结点|
|内存地址连续，可直接计算得到某个元素的地址|内存地址连续，必须依次查找|
|逻辑上连续，物理上连续|逻辑上连续，物理上不连续|

### 申请方式

#### C方式

#####  `void *malloc(unsigned size)`

申请`size`字节的连续内存空间，返回首地址，对申请到的空间不做初始化操作，如果申请不到，返回`NULL`。

#####  `void *calloc(unsigned n,unsigned size)`

申请 `n*size`字节的连续内存空间，返回首地址，对申请到的空间作置零初始化操作。

#####  `*realloc(void *ptr,unsigned newsize)`

ptr必须是malloc，calloc或者realloc返回的指针，如果ptr为NULL，则相当于malloc(不作初始化)；如果ptr非NULL，newsize为0，则相当于free，并返回NULL。
新老空间不一定重合，若不重合，原空间原有内容会被复制到新空间，再释放原空间。

如果申请不到，则返回NULL，此时已有指针ptr不释放，因此不推荐`p=(ElemType*)realloc(p,newsize)`的用法，因为可能会因为申请失败而丢失原来指向的数据。

c++方式中没有现成的realloc函数

#### C++方式

使用 `new`运算符

```cpp
int *p;\\先定义指针变量，再申请
p=new int;
int *q=new int;\\定义指针变量时同时申请
int *r;
r = new int(10);\\申请空间时赋初值
int*s=new int(10);\\申请空间时赋初值
int *t=new int [5]{1,2,3}\\申请一维数组时赋初值，[]内必须有大小，不要在{}前加=
\\对于字符型数组，Dev/Linux不支持字符串方式初始化
\\n维数组初始化时要有n层花括号
```

### 释放方式

#### C方式

直接使用`free(p)`即可

谁申请，谁释放，只有调用alloc函数分配的才需要手动用free释放，而自动变量是由操作系统分配，由操作系统回收。

#### C++方式 

对于普通类型变量的指针，只需 `delete p`

对于指向数组的指针，以及指向自定义class的指针，必须要用 `delete []p`

#### 释放顺序

如果是嵌套申请，则由外至内申请，由内至外释放

如果是释放数组，那么也是最后申请的先释放，也就是下标越大，越早释放。

### 结构体和对象的内存申请

#### string

由于将超过string大小的字符串赋值给string后大小仍然不变，因此可以推断出string实际上是一个类或结构体，其中的一个成员为指向字符串的指针。用于储存字符串的内存是动态分配的。

#### C方式

使用c方式来为结构体以及对象申请内存空间时，它只会申请一块内存空间，并不会调用对应的对象的构造函数，此时如果不作其他额外的操作而直接对这些对象的成员进行操作的话，便会产生错误。

在使用 `free`进行内存释放时，也不会自动调用析构函数，总之，不推荐在cpp中仍然使用c方式

#### cpp方式

如果结构体或对象有成员需要动态内存申请的话，则需要在该结构体或对象的析构函数中对该成员进行释放。这样的话，在用`delete`释放结构体或对象的内存时，会自动调用该结构体的析构函数来释放掉对象的内存。

### 对象的赋值与复制

#### 对象的赋值

含义为将一个对象的所有数据成员的值对应赋值给另一个已存在对象的数据成员。相当于内存的拷贝。

如果赋值的对象的成员中涉及动态内存申请的话，赋值后两个对象的该成员指向的地址都相同，
最后两个成员的析构函数都会被调用，从而该地址会被释放两次，导致错误。同时，在赋值的过程中，其中一个的成员所指向的内存地址会丢失。

注意，如果成员为数组的话，数组在内存中实际上是该结构体的连续的一部分，在赋值时被完全替换掉，如果不是指针数组的话，将不会产生内存问题。

解决方法是对赋值运算符进行重载

### 对象的复制 

之所以称为复制，可以用平时的复制粘贴来理解，平时的复制便是创建一个新对象，而赋值总是赋给一个已经存在的变量。

含义为：建立一个新对象，其值与某个已有对象完全相同
在进行复制操作时，程序会自动调用复制构造函数，也称为拷贝构造函数。如果不自定义复制构造函数，则系统默认的复制构造函数的作用相当于赋值操作。
因此如果成员中不涉及内存申请的话，并没有必要自定义复制构造函数
复制构造函数时构造函数中的一类，是其他构造函数的重载，其形参表为`const 类名 & 对象名`

形参中的`const`可以不是必要的，但是没必要去掉，`&`则是必要的，否则在单向传值的过程中仍然会触发复制构造函数，形成死循环

进行复制时，既可以使用赋值表达式，也可以用调用函数的方式`类名 新对象名(被复制的对象名)`

复制构造函数的调用时机有：

1. 用已有对象初始化一个新建立的对象时
2. 函数形参为对象，实参向形参进行单向传值时
3. 函数的返回类型是对象时

不包括：

1. 形参为引用的情况
2. 不包括赋值操作

#### NRV技术

NRV优化技术能够使得当函数返回类型为对象且被返回的是一个自动对象时，不调用复制构造函数而直接将原空间映射为新名字（即直接利用原来的内存空间），从而提高运行速度（少复制一次内存）

使用NRV时不会调用构造函数，因此NRV技术的副作用时无法像自定义的复制构造函数增加自定义的操作。

### 深拷贝与浅拷贝

浅拷贝只复制对象的指针，而不是复制对象自身；新旧对象共享内存；修改其中一个的值则另一个会随之改变；两个对象是联动的。

深拷贝则是复制对象自身，新旧对象分别占用不同内存；修改其中一个的值不会影响另一个；两个对象是完全独立的。

## 泛型编程

### 条件编译

```cpp
#ifdef A
如果之前有宏定义A，则编译语句
#ifndef B
如果之前没有宏定义B，则编译语句
#else
如果之前有宏定义B，则编译语句
#endif
#if A
如果有宏定义A，且值为真，则编译语句
#endif
#if defined(A)||defined(B)
如果有宏定义A或宏定义B，则编译语句
#endif
```

语法和条件语句类似，不同之处在于这里通过条件判断的是是否要进行编译，而非是否执行，不符合条件的分支在这里根本不会出现在可执行文件中。

### 纯c方式

采用条件编译和`typedef`来实现泛型编程。其中当`ElemType`为数组时，当需要传入指针时应该传入的行地址`&数组名`，否则是元素地址，与普通变量的地址并不对应。

结构体可以直接用`memcpy`来拷贝内存中的数据。

## 位运算

### 字节和位

字节byte是计算机中数据表示的基本单位，位bit则是计算机中数据表示的最小单位。

1byte=8bit

### 位运算基本规则

位运算即以bit为单位进行数据的运算。

位运算也遵循整型提升的规则，要求运算数据长度相等，若不等，则右对齐，按符号位补齐左边。对于有符号数，符号位是最高位，对于无符号数，符号位一直是0.

### 与`&`

与0，1进行按位与的效果分别为清零和保留。

### 异或`^`

运算规则为：相同为0，不同为1

与1进行异或的效果为翻转

可以用于两数交换，当两个变量相同时该方法失效

```cpp
int a ,b;
a = a^b;
b = b^a;
a = a^b;
```

### 左移`<<`

运算规则为：左移数据，右补0.

### 右移`>>`

在C/C++中，运算规则为：右移数据，左补符号位

## 带参`main`函数

### `int main(int argc, char **argv)`形式

#### `argc`参数

含义为参数的个数，若不带参数，则为1，即指的是`程序名`这个参数

#### `argv`参数

含义为参数的内容，用指针数组表示，每个元素是一个字符串，最后一个是`NULL`

`argv`有`argc+1`个元素，第一个元素是程序名。

### `int main(int argc, char **argv, char **env)`形式

`env`参数的含义是：操作系统的环境变量，用指针数组来表示，每个元素是一个字符串，最后一个元素是 `NULL`。

## 共用体 

### 定义 

```cpp 
union 共用体名{
    共用体成员1（类型名 成员名）
    ……
    共用体成员n（类型名 成员名）
}
```

### 特点 
 
共用体的所有成员从同一内存开始，共用体的大小为其中占用空间最大的成员的大小。因此给一个共用体成员赋值后，会覆盖其他成员的值，因此只有最后一次存放的成员会是有效的。

成员是最低位相互对齐。

## 枚举类型 

## 定义 

```cpp 
enum 枚举类型名{枚举元素1，……，枚举元素n}；
```

枚举类型也称枚举常量，不是字符串，不加`""`，作为整型常量处理，值从0开始顺序递增，也可自行指定。

```cpp 
enum 枚举类型名 变量名
```

枚举类型变量可以直接用枚举类型中的枚举元素来赋值，或者也可以用整型强制类型转换后再赋值，值必须要是枚举类型常量的范围。

当定义了枚举类型后，其中的枚举元素就像常量一样，再程序的其他地方也可以调用。

## `typedef`

```cpp
typedef 已有类型 新名称；
```

使用的方法一般为：

1. 确定一个新名称
2. 确定该新类型用已有类型是如何表示的
3. 将原表示方式中的变量名转为新的名称

例如 `typedef int Array[10]`定义的便是一个大小为10的整型数组的新名称。

## 输入输出

### 输入输出类型

1. 标准I/O:从系统设备中进行输入输出
    - 操作相同将所有系统设备统一当作文件进行处理
2. 文件I/O:从外存文件中进行输入输出
3. 串I/O:在内存空间中的一个字符数组/`string`中进行输入输出

### 路径

`\`开始的路径是绝对路径，即默认从当前目录的盘开始按照所给路径寻找。如果在前面加上盘符，则会在指定盘开始按照路径寻找。

cmd下运行exe时的当前目录是exe所在目录，而在vs中调试时，当前目录是cpp文件所在位置。

## 文件操作

### 文件种类

文件即存储在外存储器上的数据的集合，文件名则是操作系统用于访问文件的依据。（系统设备也算文件，如键盘，打印机）

文件按照数据的组织形式可以分为：

1. ASCII码文件，即按数据的ASCII代码形式存放的文件
2. 二进制文件，即按数据的内存存放形式存放的文件

ASCII码文件是给人阅读的，而二进制文件则是给机器阅读的。因此二进制文件中的数据是按照机器内部的形式保存的，例如浮点数是按照IEEE754的方式，而字符串也有尾零。而ASCII码文件则是在二进制文件的基础上，经过加工，把给人读的信息保留下来，因此它中间没有尾零等概念。

### 文件结束符与文件结束标记

新起一行输入`^Z`会视为文件结束符。

文件结束标记则是`EOF`，为宏定义。

### C++输入输出流

`cin`,`cout`与`<<`,`>>`作运算后返回的是自身。

`cin`,`cout`本质是一个类的对象，所以有`set.width(20)`等成员函数使用方式。

`<<`，`>>`本质是运算符，因此可以通过运算符重载来实现自定义数据类型的输入输出。

`ifstream`,`ofstream`,`fstream`这三个类分别用于输入文件，输出文件，以及文件的输入以及输出。

统一的头文件是`fstream`。

#### 输出流类型

1. `cout`：用于常规输出，缺省是显示器
2. `cerr`：用于错误信息输出，缺省是显示器，会直接输出，不等待缓冲区满或回车
3. `clog`：用于日志信息输出，缺省是显示器，等待缓冲区满或回车才输出。

`getche`中的 `e`的含义是 `echo`，即有回显。

#### 打开文件

打开文件的语法为`文件流对象名.open(文件名，打开方式)`，各个打开方式用位或运算符`|`在进行叠加。

*ios::binary的影响对于只是在对于回车键以及EOF的处理上发生变化，也就是说仍然在用读写文本文件的方式进行读写，只不过告诉程序实际上是在读写二进制文件，要进行微调。注意，文本文件中可以有非图形字符，即一个字节上的值是0-255*

*或者说文件的读写一直是一个字节一个字节的，只不过当以文本文件读写时，每个字节的值是有实际意义的，比如EOF等，而当以二进制文件读写时，每一个字节在读写时是没有意义的，尽管可能是一个字符对应的一个字节，只有当这些字节被放置在对应的内存空间后才有含义*

也可以用`ofstream out("文件名",打开方式)`直接在声明时打开。

每个文件被打开后，都有一个文件指针，初始指向开始/末尾的位置，根据打开方式决定，用于指示在当前文件中的偏移位置。（与指针变量的概念无关）

执行打开操作后，要和申请内存时一样判断是否成功，可以用`if(!文件流对象名)`,`if(文件流对象名.is_open()==0)`,以及`if(!文件流对象名.is_open())`来判断。其他方式均错误。

#### 使用方法 

文件流类的使用方法与输出输入流类的使用方法一致。但是打开文件后要使用`文件流对象名.close()`关闭文件。

#### 二进制文件处理

如果像ASCII码文件读取字符一样处理，则一次只能读取一个字节，一旦读取到`0x1A`，即`^Z`，也即`EOF`时，将停止读取，正常文本中不会有该字符，但二进制文件中经常会出现。

##### `read`和`write`函数

使用方式为 `文件流对象名.read(存储内存空间首指针，读取字节长度)`和`文件流对象名.write(输出内存空间首指针，输出字节长度)`

这两个函数会严格执行指定长度，无视内存中的信息。但是如果可读取长度超过指定长度，则只会读取可读取的长度。

#### 与文件指针有关的流成员对象

*cin.eof()*只有当读入了`EOF`以后才为`true`，如果在循环输出文件内容时，要避免将`EOF`也输出。

适用于输出文件：

1. `gcount()`：返回最后一次读入的字节数
2. `tellg()`：返回输入文件的当前指针
3. `seekg(位移量，起始点)`：移动输出文件指针

适用于输出文件的：

1. `tellp()`：返回输出文件的当前指针
2. `seekp(位移量，起始点)`：移动输出文件指针 

起始点：

1. `ios::beg`：从文件头部
2. `ios::cur`：从当前位置
3. `ios::end`：从文件尾部

如果采用`fstream`，则`tellg/tellp`是同步移动的

### C语言的文件操作

#### 文件对象`FILE`

用 `FILE *`类型来定义文件指针，然后使用 `FILE *fopen(文件名,打开方式)`来打开文件，最后用`fclose(文件指针)`来关闭文件。

#### 文本文件读写相关函数

1. `int fgetc(文件指针)`
   - 同C++方式，仅能按照字符读写，且文件中不能有`0x1A`
2. `int fputc(文件指针)`
3. `int feof(文件指针)`：用于判断是否到达文件尾部
4. `int fscanf(文件指针，格式串，输入表列)`
5. `int fprintf(文件指针，格式串，输出表列)`

#### 二进制文件读写相关函数

1. `int fread(缓冲区首地址，块大小，块数，文件指针)`
2. `int fwrite(缓冲区首地址，块大小，块数，文件指针)`
3. `rewind(文件指针)`：指针复位
4. `fseek(文件指针，位移量，位移方式)`
   - 位移方式有：`SEEK_SET`,`SEEK_CUR`,`SEEK_END`
5. `ftell(文件指针)`求文件指针的当前位置

#### 重定向

系统预置一下三个`FILE *`:

1. `stdin`:标准输入设备
2. `stdout`:标准输出设备
3. `stderr`:错误输出设备

可以用 `FILE *freopen(文件名，打开方式，原文件指针)`来将原文件指针指向重新指向给定的文件名

### `popen/pclose`

为C语言特有，可以打开一个程序来进行读入和写入，注意，系统命令本质上也是一个程序。

打开后，如果使用`fprintf`等对文件写入的函数，则实际效果是相当于运行该程序并进行输入。如果是读入文件的函数，则实际结果是读入该程序的输出。

### C++的字符串流(`sstream`)

即以内存中的`string`类型变量为输入/输出对象

可以存放各种类型的数据，与标准输入输出流相同，进行文本和二进制之间的相互转换

向`string`存数据即把二进制转化为文本，取数据则是文本转为二进制。

#### 字符流对象使用

1. 字符串输出流对象：`ostringstream`
2. 字符串输入流对象：`istringstream`
3. 字符串输入/输出流对象：`stringstream`

需要头文件`<sstream>`，但是不需要进行打开和关闭。

如果现有内容全部读完，则`s.good()`为0

和`cin`一致，如果读入的数据超范围了，`good()`也会为0，之后不再读入，即使重新向流对象赋值也无法改变错误状态，需要用`clear()`进行重置

### C语言下实现流字符串功能

使用`sprintf(字符数组，"格式串"，输出表列)`，其返回值时输出字符的个数，指不同类型数据按格式串的要求转化为文本方式后字符的个数。是二进制向文本的转换。

常见的使用方法是用一个指针指向字符数组，每次增加`sprintf`的返回值来实现连续不覆盖写入

使用`sscanf(字符数组，"格式串"，输入表列)`可以实现从文本向二进制的转换，返回值是正确读入的输入数据的个数。

## 运算符重载

运算符重载主要用于解决自定义类与原生数据类型之间的运算问题。
解决某一类的运算用的重载函数是那一类的成员函数。
当进行`对象 重载运算符`时，实际上是`对象.operator运算符()`

同时，也可以用把重构函数作为那个类的友元函数来实现运算符重载，这种方式往往更加灵活

|待重载运算符类型|实现方式|形参表|对应运算|
|--|--|--|--|
|双目运算符|类的成员函数|指定类型|运算的前项为该类，后项为指定类型|
|双目运算符|类的友元函数|指定类型1，指定类型2|运算的前项为指定类型1，后项为指定类型2|
|单目运算符|类的成员函数|空|运算的作用对象为对象自身|
|单目运算符|类的友元函数|类|运算的作用对象为对象自身|

c++规定，`=`,`[]`,`()`的重载必须要用成员函数来实现，而`>>`,`<<`则必须用友元函数来实现。

一般建议单目运算符用成员函数实现，双目运算符则用友元函数来实现。

为了覆盖所有可能的情况，常常采用多个类的友元函数来重载运算符

### 运算符重载的规则

1. 对已有运算符进行重载，不能定义新运算符
2. 除5个运算符`.`(成员访问运算符),`*`(成员指针访问运算符),`::`(域运算符),`sizeof`(长度运算符),`?:`(条件运算符)外，都允许重载。
3. 不能改变操作对象的个数
4. 不能改变结合性
5. 不允许带默认参数
6. 重载运算符的两侧至少有一个是类对象
7. `=`,`&`系统缺省做了重载，`=`是对应内存拷贝,`&`是取地址

### 作为成员函数的重载函数的编写

当重载函数为类的成员函数时，其体外实现的编写形式为：

```cpp
类名::返回类型 operator 运算符(形参表)
{
    重载函数实现
}
```

编写时有一下注意事项：

1. 返回类型： 要根据实际用途以及原生的运算符的性质来确定，例如`=`，它的返回类型不为`void`，而是所赋的值。如果是返回对象自身的话，当涉及到动态内存申请时要小心。如果返回的不是引用类型，则有可能调用复制构造函数，如果是默认的复制构造函数话，便会造成内存错误。同时，如果返回值是可以修改的左值，例如`a=b`的返回值其实是`a`，可以通过`(a=b)++`来修改`a`的值，那么在编写对应的重构函数时，其返回值应该是被赋值的变量的引用。如果返回的不是可以修改的左值，则需要返回的是临时变量，即不能返回引用
2. 由于运算符函数的实参可能是常量，在定义形参表时要保证不会出现获取更高权限的错误。例如当形参表中为`double &`时，对应的实参不能是常数，因此应该将形参改为`double`或者改为`const double &`
3. 重载函数实现时，有些时候要特判运算符两边的对象是否为同一对象的情况，例如`=`

### 复制构造函数与重载赋值运算符之间的比较

||复制构造函数|重载赋值运算符|
|--|--|--|
|系统缺省|内存拷贝|内存拷贝|
|必须定义的时机|含动态内存申请时|含动态内存申请时|
|调用时机|定义时用对象初始化（包括`class a = b`的情形）；对象为函数形参或函数返回值|执行语句中的`=`操作|
|调用时处理|新对象生成时调用，从未进行过动态内存申请，无需考虑内存空间释放|已有对象以前已经进行过动态内存申请，此时要考虑内存释放|