# 数据结构设计与算法设计

时间:2023年秋季

本笔记结合数据结构与算法设计的课堂内容以及
*Data structures and Algorithm Analysis in C*.
部分数学基础内容来自于 *Concrete Mathematics*.

## 课程基本信息

### 上课形式

- 课堂
- 机房上机: 星期二晚上,第三周开始

### 课程考核

- 考勤:10%:课堂和上机
- 实验作业:35%(OJ系统,有查重)
- 课堂表现:10%(小测,研讨和平时提问)(可能单周四节连上时最后半节课会有小测)
- 期中考试:15%(大概率闭卷考,也有可能是大作业)
- 期末考试:30%

## 第一章:绪论

### 数学基础

#### 数项级数

\[\sum_{i=1}^N i^k\approx\frac{N^{k+1}}{\lvert k+1\rvert}\phantom{wwwww}k\neq -1\]
\[H_N=\sum^N_{i=1}\frac{1}{i}\approx\log_eN\]

#### 模运算

如果 $a\equiv b(\text{mod} n)$,那么有
\[a+c\equiv b+c(\text{mod} n )\]
\[ad\equiv bd(\text{mod} n )\]

#### 求解递归表达式的封闭形式

##### 求解含有可变参数的递归表达式

对于没有可变参数的递归定义函数, 我们可以先列表计算出前若干项,然后观察规律,
猜测出合理的封闭形式,然后利用数学归纳法证明.

对于含有可变参数的递归定义函数,例如
\[\begin{cases}
R_0=\alpha\\
R_n=R_{n-1}+\beta+\gamma n
\end{cases}\]
如果最终的闭合形式是可变参数的线性组合(有时要靠猜测),例如 $R_n=A(n)\alpha+B(n)\beta+C(n)\gamma$
那么我们可以把一些简单的方程代入递归定义表达式，解出每个方程对应的可变参数。最后把这些参数和对应的方程代入线性组合形成线性方程组。解出线性方程组即可。
方程选取的准则是可以轻松解出参数，方程选取的个数应该要让线性方程组有唯一解。

##### 求解$a_nT_n=b_nT_{n-1}+c_n$形式的递归表达式

整体思想是将该递归表达式的求解转化为对求和形式的求解。为此我们要找到求和因子$s_n$，满足
\[s_nb_n=s_{n-1}a_{n-1}\]
从而
\[s_na_nT_n=s_nb_nT_{n-1}+s_nc_n=s_{n-1}a_{n-1}T_{n-1}+s_nc_n\]
记 $S_n=s_na_nT_n$,则
\[S_n=S_{n-1}+s_nc_n\]
从而有
\[S_n=s_0a_0T_0+\sum^n_{k=1}s_kc_k=s_1b_1T_0+\sum^n_{k=1}s_kc_k\]
所以
\[T_n=\frac{1}{s_na_n}S_n\]
其中 
\[s_n=\frac{a_{n-1}a_{n-2}\cdots a_1}{b_nb_{n-1}\cdots b_2}\]

##### 利用指标替换求解双重求和表达式

如果我们有一个双重求和表达式，被求和的元素中含有 $k+f(j)$，其中 $f$是任意函数，
那么我们可以尝试将 $k$ 替换为 $k-f(j)$，并优先对 $j$ 求和。

例如 
\[
S_n=\sum_{1\leq j<k\leq n}\frac{1}{k-j}=\sum_{1\leq j<k+j\leq n}\frac{1}{k}=\sum_{1\leq k\leq n}\sum_{1\leq j \leq n-k}\frac{1}{k}
\]
在该例中，我们从按行或列求和转化为按照对角线求和，从而简化了求和过程。

#### 求解求和表达式的封闭形式

##### 微扰法

\[\begin{array}{rl}
S_n+a_{n+1}=\sum_{0\leq k\leq n+1}a_k&=a_0+\sum_{1\leq k\leq n+1}a_k\\
                                     &=a_0+\sum_{1\leq k+1\leq n+1}a_{k+1}\\
                                     &=a_0+\sum_{0\leq k\leq n}a_{k+1}\\
\end{array}\]
如果我们能将最后一个求和号转化为关于$S_n$的关系式，那么我们便可以得到关于 $S_n$的关系式，并从中解出$S_n$的封闭形式。

##### 利用微积分求解

我们可以把求和表达式中的参量视为变量，从而把求和表达式视为以那个参量为自变量的函数项级数，从而对其利用积分和微分等操作。

例如，为了求解 $\sum_{k=0}^nx^k$，我们有
\[\sum^{n}_{k=0}x^k=\frac{1-x^{n+1}}{1-x}\]
对其两边对$x$求导可得
\[\sum_{k=0}^nkx^{k-1}=\frac{1-(n+1)x^n+nx^{n+1}}{(1-x)^2}\]
对其等号两边同乘以 $x$，便可得到欲求的封闭形式。

#### 求和记号

##### 交换律

\[\sum_{k\in K}a_k=\sum_{p(k)\in K}a_{p(k)}\]
其中 $p(k)$ 是 $K$ 的一个置换。
如果我们用 $f(j)$来代替 $k$，其中 $f$是任意一个从 $J $到 $K$上的映射，那么
\[\sum_{j\in J}a_{f(j)}=\sum_{k\in K}a_k\#f^-(k)\]
其中 $\#f^-(k)$代表着集合
\[f^-(k)=\{j|f(j)=k\}\]
中的元素个数。

##### 分配律

多重求和的分配律为
\[\sum_{j\in J,k\in K}a_jb_k=(\sum_{j\in J}a_j)(\sum_{k\in K}b_k)\]

##### 结合律

多重求和的结合律的一般形式为
\[\sum_j\sum_ka_{j,k}[P(j,k)]=\sum_{P(j,k)}a_{j,k}=\sum_k\sum_ja_{j,k}[P(j,k)]\]

当内外层的求和指标相互独立时，有化简形式：
\[\sum_{j\in J}\sum_{k\in K}a_{j,k}=\sum_{j\in J,k\in K}a_{j,k}=\sum_{k\in K}\sum_{j\in J}a_{j,k}\]

当内外层的求和指标相互独立时，若要相互交换，即：
\[\sum_{j\in J}\sum_{k\in K(j)}a_{j,k}=\sum_{k\in K'}\sum_{j\in J'(k)}a_{j,k}\]
其中的求和条件需要满足：
\[[j\in J][k\in K(j)]=[k\in K'][j\in J'(k)]\]
特别地，我们有
\[[1\leq j\leq n][j\leq k\leq n]=[1\leq j\leq k\leq n]=[1\leq k\leq n][1\leq j\leq k]\]
即 
\[\sum_{j=1}^n\sum_{k=j}^na_{j,k}=\sum_{1\leq j\leq k\leq n}a_{j,k}=\sum_{k=1}^n\sum_{j=1}^ka_{j,k}\]

##### 有限微积分（FINITE CALCULUS）

在有限微积分中，我们定义差分算法$\Delta$和位移算符$E$分别为
\[Ef(x)=f(x+1)\phantom{111} \Delta f(x)=Ef(x)-f(x)\]
并且定义上下阶乘分别为
\[x^{\underline{m}}=x(x-1)\cdots(x-m+1)\phantom{111}x^{\overline{m}}=x(x+1)\cdots(x+m-1)\]
其中整数$m\geq 0$。$x$的 $m$上下阶乘中均有 $m$个因子。我们规定 $x$的0上下阶乘均为1。
易证
\[\Delta(x^{\underline{m}})=mx^{\underline{m-1}}\]
我们规定
\[g(x)=\Delta f(x)\text{ 当且仅当 }\sum g(x)\delta x=f(x)+C\]
其中 $C$为任意满足 $f(x+1)=f(x)$的函数
类似于微积分基本定理，如果 $g(x)=\Delta f(x)$，则
\[\sum\nolimits_a^bg(x)\delta x=\left.f(x)\right|^b_a=f(b)-f(a).\]
其中 
\[\sum\nolimits^b_ag(x)\delta x=\sum_{k=a}^{b-1}g(k)=\sum_{a\leq k<b}g(k),\phantom{111}b\geq a\]
和积分符号类似地，我们有$\sum_a^b=-\sum_b^a,\sum_a^b+\sum_b^c=\sum_a^c$。
我们进一步定义
\[x^{\underline{-m}}=\frac{1}{(x+1)(x+2)\cdots(x+m)},\phantom{111}x>0\]
可以验证，我们有
\[x^{\underline{m+n}}=x^{\underline{m}}(x-m)^{\underline{n}}\]
在有限微积分中，我们用下阶乘来类比次幂，我们还用调和级数来类比自然对数：
\[
  \sum\nolimits_a^bx^{\underline{x}}\delta x=
  \begin{cases}
  \left.\frac{x^{\underline{m+1}}}{m+1}\right|^b_a,&\text{当}m\neq -1;\\
  \left.H_x\right|^b_a,&\text{当}m=-1.\\
  \end{cases}
  \]
并用$2^x$来类比 $e^x$：
\[\Delta(c^x)=(c-1)c^x\phantom{111}\sum_{a\leq k<b}c^k=\sum\nolimits_a^bc^x\delta x=\left.\frac{c^x}{c-1}\right|^b_a=\frac{c^b-c^a}{c-1},\phantom{111}\text{当}c\neq 1\]
在有限微积分中，并不存在链式法则，变量替换也较为困难，但是仍然存在分部积分的类比：
\[\Delta(uv)=u\Delta v+Ev\Delta u\]
\[\sum u\Delta v=uv-\sum Ev\Delta u\]

有限微积分十分强大，给我们提供了系统性求解求和表达式的工具
例如：
\[
  \begin{array}{rl}
    \sum xH_x\delta x&=\frac{x^{\underline{2}}}{2}H_x-\sum\frac{(x+1)^{\underline{2}}}{2}x^{\underline{-1}}\delta x\\
    &=\frac{x^{\underline{2}}}{2}H_x-\frac{1}{2}\sum x^{\underline{1}}\delta x\\
    &=\frac{x^{\underline{2}}}{2}H_x-\frac{x^{\underline{2}}}{4}+C\\
  \end{array}
  \]
  因此我们有
  \[\sum_{0\leq k<n}kH_k=\sum\nolimits^n_0xH_x\delta x=\frac{n^{\underline{2}}}{2}(H_n-\frac{1}{2}).\]

#### 渐进表达式

若当n足够大时存在常数c使得
\[T(n)\leq cf(n),\]
我们记
\[T(n)=O(f(n))\]

### 递归函数设计要素

1. 要设置初始条件
2. 每一次递归后都要向初始条件靠近
3. 设计时将所有使用的更底层的递归视为能正确工作
4. *Compound interest rule.* Never duplicate work by solving the same instance of a problem in separate recursive calls.这也是为什么不推荐用递归函数来求解简单数学函数,如斐波那契数列,的值的原因.

### 算法分析

在估算时间复杂度时,不要忘了条件语句中的判断,以及for语句中每次循环的增量语句.

总体有五条法则:

1. 对于循环而言,其复杂度最多是其内部语句的复杂度乘以循环次数
2. 对于嵌套循环而言,其语句是循环语句乘以所有循环的循环次数.
3. 对于顺序语句:抓住重点,整体的复杂度取决于最复杂的语句.
4. 对于条件语句:其复杂度不超过判断语句加上第一复杂的分支语句的复杂度
5. 从内层向外层进行分析,如果有函数调用,则先分析函数

### ADT 设计要点

1. 要使用sizeof来确定类型大小,因为即使是同一类型,在不同的环境中也有可能有不同的大小.
2. 在定义操作时要在程序中检查传入参数的合法性,例如检查下标是否超出范围,是否内存溢出等等.
3. 顺序表等类型在插入元素时从列表的最后一位开始向后平移,如果从被插入处开始平移的话,则需要中间变量来存储被覆盖的数据.
4. 不再使用的内存空间要即使释放。

## 第二章:基本概念

### 数据结构

数据结构时相互之间存在一种或多种关系的数据元素的集合,这种数据元素之间的关系加上数据元素本身便是所谓的结构.
其形式定义为二元组(D,S),其中D是数据元素的有限集,S是D上关系的有限集.

D 中若是有序数对,例如线性结构,树型结构,则用<>来表示,若为无序数对,则用()来表示.

数据即能够输入到计算机中并被处理的符号的集合.
数据元素是数据的基本单位,常被视为一个整体来处理.
数据项则是数据的不可分割的最小单位
数据对象则是性质相同的数据元素的集合,是数据的一个子集.

数据结构可以按照其逻辑结构和物理结构以及允许的操作来进行分类

#### 逻辑结构

四种基本逻辑结构为:

1. 集合:元素仅属于同一个集体,没有其他关系
2. 线性结构:存在一对一关系(如每个元素对应其后继),序列相邻,并有次序关系
3. 树型结构:存在一对多关系以及层次关系
4. 图状结构:存在多对多关系,具有任意性

#### 物理结构(存储结构)

我们把存储器建模为一系列固定大小的存储单元,每个单元有一个唯一的地址,该地址被连续编码.
同时每个单元有唯一的后继单元.

物理结构便是逻辑结构到存储器的一个映射,分为:

1. 顺序存储:利用元素在存储器中的相对位置来表示之间的逻辑关系
2. 链接存储:利用指针
3. 索引存储:存储节点外还建立索引表,其每一项称为索引项,形式为:关键字,地址
4. 散列存储:根据节点的关键字直接计算出该节点的存储地址

#### 数据结构允许的操作 

1. 静态结构--操作后,数据的结构特性不变,例如数组
2. 半静态结构--操作后,数据的结构特性轻微改变,如栈,队列
3. 动态结构--操作后变换灵活,可随意重新组织结构,如指针.

### 抽象数据类型-ADT

ADT是指基于一个逻辑类型的数据模型以及定义在该模型上的一组操作。每一个操作由它的输入和输出定义。
其形式定义为三元组(D,S,P),S是D上关系的有限集,P是对D的基本操作集.

ADT的定义不涉及具体实现,即是被封装了的.数据结构则是其物理实现.

抽象数据类型与数据类型实际上是同一个概念

### 算法与算法分析

#### 算法的定义

算法是指一系列确定的并且是在有限步骤内能完成的操作.
算法具有有穷性,确定性,可以没输入,但必须有输出,同时具有可行性.

程序不具有有穷性,因此不是算法.

#### 算法设计

算法和数据结构是相互依赖的.

一个好的算法首先要正确,同时要具有可读性,并且有一定的容错性以及时间和空间上的效率,即能
在有限的时空资源内将问题解决.

## 线性表 

### 线性结构

线性结构即一个满足以下条件的数据元素的非空有限集:

1. 有一个开始节点
2. 有一个终端节点 
3. 其他节点有且仅有一个前驱和一个后继 

### 线性序列

线性序列则是线性结构中所有节点按其排序排成的一个序列,记为 
\[(a_1,\cdots,a_i,a_{i+1},\cdots,a_n)\]

### 线性表的类型定义

线性表是一个有限序列 ,是最常用最简单的数据结构.
数据结构描述为:
\[List=(D,R)\]
\[其中D=\{a_i|a_i\in D_0,i=1,2,\cdots,n,n\geq 0\},R=\{R\},N=\{<a_{i-1},a_i>|a_{i-1},a_i\in D_0,i=2,3,\cdots,n\}\]
$D_0$为某个数据对象.

线性表具有均匀性和有序性

线性表中的元素下标从1开始,元素的下标称为该元素在线性表中的位序.线性表支持增加和删除元素,

### 线性表的存储结构

#### 顺序表

定义为在计算机内存中用一组地址连续的存储单元依次存储线性表中的各个数据元素.

即用物理位置的相邻以及前后关系来表示数据元素之间的(线性)逻辑关系.

优势有:

1. 随机存储结构:如果每个元素占用的存储单位固定,只需要知道顺序表的起始位置(或称为基地址)以及元素的位序,便可以直接算出该元素所在位置.
2. 存储效率高,是紧凑结构
3. 结构简单

缺点有:

1. 进行插入和删除操作时,需要移动数据元素,算法效率较低
2. 对于长度变化较大的线性表,或者要预先分配较大空间或者要经常扩充线性表,给操作带来不方便.
   - 原因在于数组的静态特性
   - 插入元素时,若长度超过分配长度，则要重新分配空间(`realloc`),而非在原来的基础上直接扩展

#### 链表

定义为在内存中用一组任意的存储单元来存储线性表的数据元素，用每个数据元素所带的指针来确定其后继元素的存储位置。这两部分信息组成数据元素的存储映像，称作结点。

即每个结点由数据域与指针域(链域),n个结点链接成一个链表.

##### 单链表

单链表也称线性链表,即一个每个结点只包含一个指针域的链表.

- 头指针:指向链表中的第一个节点(可能是头结点,也可能时开始结点)
- 开始结点:第一个数据元素结点
- 头结点:有时会在单链表的第一个元素节点之前附设一个节点,称为头结点
  - 其next域指向链表中的第一个数据元素结点
  - 其数据域可以作一下处理:
    - 加特殊信息
    - 置空
    - 如数据域为整型,则在该处存放链表长度信息.
  - 优势有:
    - 开始结点的位置也被存放在另一个结点(头结点)的指针域中,因此无需对其作特殊处理
    - 无论链表是否为空,其头指针是指向头结点的非空指针,使得对空表和非空表处理统一起来
    - 判断链表是否为空可以用`if(L->next)`来判断,其中`L`为头指针
  - 因此常常使用含有头结点的链表

###### 结点的删除

要删除一个节点时,一定要先用一个变量来保存删除节点的指针域,否则其后面的链表会丢失.

同时,最后要用`free(p)`来释放被删除的结点所占用的空间.

##### 循环链表

循环链表即首尾相接的链表。其最后一个节点的指针域不为`NULL`。循环条件为`p->next != H`，其中 `H`为头指针。
为了简化操作，常常在循环链表中加入表头节点。

##### 双向链表

双向链表即在前驱和后继方向都能遍历的线性链表。双向链表通常采用带表结点的循环链表形式。
显然，在一个双向链表中有`p == p->prior->next==p->next->prior`。特别地，对于空表，`p->prior == p==p->next`
在删除一个结点前，一定要有一个工作指针指向它，为了之后便于释放该位置。
创建双链表时，L是一个指针，因为要改变L中的值，例如分配给它空间，所以要用`&L`，即引用来传参。

##### 不同形式的链表间的比较

|单链表|循环链表|
|--|--|
|必须从头指针开始遍历|可以从任一结点出发开始遍历|
|表尾指针的指针域为`NULL`|表尾节点的指针域是指向链表头节点的指针`H`，没有指针域为`NULL`的结点|

##### 线性链表可改进的地方

用上述定义的单链表实现线性表的操作存在如下问题：

1. 单链表的表长是个隐含的值
2. 在单链表的末尾插入元素时，需要遍历整个链表
3. 在链表中，元素的“位序”概念淡化，结点的位置概念强化

对此，我们可以：

1. 增加“表长”，“表尾指针”，“当前位置指针”三个数据域；
2. 将基本操作由“位序”改变为“指针”

#### 不同存储结构之间的比较

||顺序表|链表|
|--|--|--|
|空间利用率|存储空间是静态分配的，在执行那个程序前预先分配一定长度的连续的存储空间，可能导致存储空间的浪费或溢出|存储空间动态分配，且无需连续，除非超级极端情况，否则不会发生溢出。但指针域需额外占用存储空间|
|时间效率|适用于主要操作为查找，并且插入和删除操作只在尾部进行的场景|适用于频繁对线性表进行任意位置的插入和删除操作的场景|
|访问特性|随机存取（直接存取）|顺序存取|

## 栈和列表

### 栈

#### 定义

栈定义为：限定只在表的一端（表尾）进行插入和删除操作的线性表。
我们用指针`top`指向栈顶，即待插入元素的位置，用`bottom`指向线性表的另一端。

##### 抽象数据类型定义

ADT Stack{
  数据对象 : $D=\{a_i|a_i\in ElemSet,i=1,2,\cdots,n,n\geq 0\}$
  数据关系 : $R=\{<a_{i-1},a_i>|a_{i-1},a_i\in D,i=2,\cdots,n\}$
  (约定 $a_n$端为栈顶，$a_1$端为栈底)
  基本操作：见数据结构实现文档
}

#### 栈的存储结构

##### 顺序栈

当 `base == NULL`时，表明栈结构不存在
当 `base == top`时，说明栈空
当 `top-base == stacksize`时，说明，栈满

##### 链栈

##### 静态分配整型指针
