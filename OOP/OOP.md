# OOP

## 高维数组

&可以作用于数组名以及变量(包括指针变量),而不可以作用于一个地址.
假设定义`int test[10]`,则`test`是数组名,而`test+1,test+1,...`均为地址.
对于一个多元数组,假设是二维数组,我们可以把整个机器的内存地址视为第一层地址,
二维数组的行为第二层,列为第三层,,可以通过`&`来降低层数.
a+0,a+1,...是以行为单位,而&a,&a+1,..是以整个二维矩阵为单位.
高维矩阵应该视为一个元素为更低一维度的矩阵的矩阵名的一维矩阵.

也就是说,对于一个n维矩阵x.
&x是回到整个机器的内存这一层,&x+i是让指针以整个矩阵大小为单位在该层移动(这实际上是
没有意义的);x+i则是在该矩阵中的第一维度移动,是以第二维度为单位,*(x+i)则是
取该指针对应的地址中的值,由于我们是在矩阵内部操作的,我们所取到的是第二维度中该地址的值,
实际上是一个数组名,等价的操作是x[i].特别地,*数组名等价于数组名[0],以及\*(数组名+0)
&x[i]是先将指针以下一层为单位移动到x+i,然后进入到下一层,取其中存储的数组名,
最后在通过&返回到原来的那一层

回到二维数组的例子,这里第二层被称为行地址,第三层被称为元素地址.

sizeof 中如果是数组名的话返回的是整个数组的大小,而如果是地址的话则是指针的大小

一个数组名作为指针时,其基类型为该数组的元素.

`int (*p)[4]`定义了一个指针,指向一个有着四个int的数组的数组名,p+i以这一整个数组为单位移动,
与一个二维数组相似.

a+1 等价于 &a[1]
a[1] 等价于 *(a+1)
&a[i] 与 a+i都是行地址
a[i]与*(a+i)都是元素地址
对行地址进行取值操作会得到元素地址
sizeof (*p)问的是基类型的大小