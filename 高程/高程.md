# 高程

**一定要一句一行**  
**鼓励复用函数**  
取反就是0，1互换  
~~原码换算为补码的逆运算是-1，取反,再变为相反数~~


以2字节-32768为例，先将其转换为其绝对值的二进制1后面在跟15个0,此时最前面的1代表着$2^{15}$也就是10进制里的32768,取反得到0后跟15个1,加一便得到1后面跟15个0,也就是原码中的-0  

要注意的时上面这个案例是极端的,在正数的原码中,第一位永远是0,而在负数的绝对值所对应的二进制中只有像上面的例子那样的极端情况才会在第一位出现1,只有此时绝对值的二进制和其原码不对应,是个特例,其他的时候绝对值的二进制表示和其原码都一样


- [x] 课后check一下


|原码|补码|
|--|--|
|-0|-32768|
|-1|-32767|
|...|...|
|-32767|-1|

负数的原码加补码等于-32768 即$-2^{15}$
计算机里对于整数的表达只有补码,没有原码
补码通过将正负0的补码统一成全都是0来消除0的二义性,也就是说它把原先的负0给消除了,这使得补码可以比原码多表示一个数,那就是-32768  
应该先去判断一个数是什么类型再去判断它的值
不同编译器的数据的长度可能不同

**对于整数型,必须占满对应字节长度**
输出的数字不会标注进制 

***每个文件都应该检查一遍配置属性 链接器 系统 子系统是否为控制台***
## 二进制与十进制小数之间的转换 

当遇到带有小数点的十进制时,并且想将其转换为二进制,对于其整数部分我们只需用常规的短除法来操作,对于其小数部分,我们将单独处理它.  
首先,写下0.xxx,其中xxx为小数点后的部分,然后我们将这个数字乘以2,取得到的数字的个位数
这个数字便是对应十进制的小数点后第一位,如果这个数字是1,那么我们在下一次操作时将这个一改为0,如果是0,那么保持不变,下一步操作是继续乘以2 ,当取了n个数后所得的数字小数点后都是0了,那么就停止操作,我们便得到了十进制下的小数.  

如果想要将二进制小数转换成为十进制小数,只需和整数部分一样采用加权展开即可.  


**要注意当把八进制或者十六进制转换为二进制时,转化的过程中间应该严格遵循1位对应3或者4位二进制,在写答句的时候可以省略最前面的0**

**需要记忆最基本的字符的ascii码**

***在正确情况下按最长原则来判别\代表什么字符 如\123应该理解为\123而不是\1和23或\12和3,对于\x而言,后面不能跟3位及以上的16进制,如fff,会报错,但是二位16进制后可以跟其他的非0-9,a-f的字,如空格***
*字符串结尾不能为\0*
c和c++中但有害和双引号有严格区别,一个是字符一个是字符串
\是转义符,\+一个字符将它转换为另外一个字符,也就是\+一个字符在内存中是另外一个字符,\不会出现在内存中
字符串的尾0的\0就是被转义到了另外一个字符,因此字符串在内存中的实际字符会多一个

***应该避免使用全文替换***

标识符长度意味着只会截取前面多少位字符,如果长度限制是2,那么对于abc和abd,两个都是合法的,但是计算机只会取前面两位即ab

dev中不支持用中文来当标识符,因此应该尽量不用
*禁用auto*
*42页第二个框中输出abc是什么,语句执行是从左到右,单个语句内部也是,a=b=c=10是先定义a并把b赋值给a,然后把c赋值给b,此时变量a,b实际上都是c的值,然后再把10赋值给c,这是abc应该都是10*

数据的溢出可以理解为65536进制

47页unsign和sign的绝对值相加为65536,快速计算

### IEEE754

IEEE754标准下所能表示的浮点数$v$的二进制形式形如 $$
(-1)^s2^E(b_0.b_1b_2\dots b_{23})$$
其在内存中占4字节,即32位,可分为三段

1. 符号位:第1位(从左往右,下同),其值记为s,只可能为0或1.为0时尾数为正,为1时尾数为负
2. 指数:第2-9位,其十进制值记为e,范围为0-255减去偏置值127后得到的数记为E,范围为-127-128,从而指数有了正负之分
3. 尾数:第10-32位,记为f,f=$b_1b_2\dots b_{23}$

特殊情况以及$b_0$由以下条件决定:

1. e=255且$f\ne0$时,该$v$表示NaN(Not a number)
2. e=255且f=0,则$v=(-1)^s\infty$
3. 若$0<e<255$,则$b_0=1,v=(-1)^s2^E(b_0.b_1b_2\dots b_{23})$(二进制),称为规格数
4. 若$e=0$且$f\ne0$时,则$b_0=0,v=(-1)^s2^{-126}(b_0.b_1b_2\dots b_{23})$(二进制),称为非规格数
5. 若e=255且f=0,则$v=(-1)^s0$

因此想要得到float型的最大值,应令$s=0,e=254,b_i=1,1\le i\le23$,得到值为
$$
2^{127}(0b1.11111111111111111111111)\approx3.4\times10^{38}
$$
下面探究float型对应的十进制有效位数.  
当我们说有x位有效位数时,即float型能够表示在float型的正最小值到正最大值和负最小值到负最大值这一范围之内的所有有效位数为x的十进制数.
由于对称性,只需考虑$s=0$的情况.
- 规格数

所能表示的十进制数可以分为254个等差数列
|E|首项|公差|末项|首末项之间所能表示的有效位数|
|--|--|--|--|--|
|-126|$2^{-126}\approx 1.2\times10^{-38}$|$2^{-126}\times2^{-23}=2^{-149}\approx1.4\times 10^{-45}$|$2^{-126}\times(2^1-2^{-23})=2^{-125}-2^{-149}$|7位(从小数点后44位至小数点后38位)|
|...|...|...|...|
|0|$2^0=1$|$2^{-23}\approx1.2\times 10^{-7}$|$2^1-2^{-23}$|7位(从小数点后6位至个位)|
|...|...|...|...|
|127|$2^{127}\approx1.7\times10^{38}$|$2^{127}\times2^{-23}=2^{104}\approx2.03\times10^{31}$|$2^{127}\times(2^1-2^{-23})=2^{128}-2^{104}$|7位(从整数部分第32位至整数部分第38位)|

值得注意的是,这里的有效位数7并不代表float型中就无法存储更多位数的数了,例如$2^{-126}+2^{-149}=1.1754944909521339404504436295952\times10^{-38}$,它就可以完整地在float型中储存下来.