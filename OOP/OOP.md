# OOP

## 指针进阶

判断数据类型的方法是,从变量名处开始向外按照优先级进行解析,例如,和`()`先结合便是函数,
和`[]`先结合便是数组,和`*`先结合便是指针.

### 高维数组

&可以作用于数组名以及变量(包括指针变量),而不可以作用于一个地址.
假设定义`int test[10]`,则`test`是数组名,而`test+0,test+1,...`均为地址.
对于一个多元数组,假设是二维数组,我们可以把整个机器的内存地址视为第一层地址,
二维数组的行为第二层,列为第三层,,可以通过`&`来降低层数.
a+0,a+1,...是以行为单位,而&a,&a+1,..是以整个二维矩阵为单位.
高维矩阵应该视为一个元素为更低一维度的矩阵的矩阵名的一维矩阵.

也就是说,对于一个n维矩阵x.
&x是回到整个机器的内存这一层,&x+i是让指针以整个矩阵大小为单位在该层移动(这实际上是没有意义的);x+i则是在该矩阵中的第一维度移动,是以第二维度为单位,`*(x+i)`则是取该指针对应的地址中的值,由于我们是在矩阵内部操作的,我们所取到的是第二维度中该地址的值,实际上是一个数组名,等价的操作是x[i].特别地,*数组名等价于数组名[0],以及\*(数组名+0)
&x[i]是先将指针以下一层为单位移动到x+i,然后进入到下一层,取其中存储的数组名,
最后在通过&返回到原来的那一层

回到二维数组的例子,这里第二层被称为行地址,第三层被称为元素地址.

sizeof 中如果是数组名的话返回的是整个数组的大小,而如果是地址的话则是指针的大小

一个数组名作为指针时,其基类型为该数组的元素.

`int (*p)[4]`定义了一个指针,指向一个有着四个int的数组的数组名,p+i以这一整个数组为单位移动,
与一个二维数组相似.

`a[i]`与`*(a+i)`等价,而`&`与 `*`能抵消,因此a+1 等价于 &a[1]
a[1] 等价于 `*(a+1)`
&a[i] 与 a+i都是行地址
a[i]与`*(a+i)`都是元素地址
对行地址进行取值操作会得到元素地址
sizeof (*p)问的是基类型的大小

### 函数指针

#### 函数指针定义

`数据类型 (*指针变量名)(形参表)`

#### 函数指针的使用

赋初值: `指针变量名=函数名`,不要带参数表

调用: `指针变量名(函数实参列表)`

函数指针`p`与`*p`打印出来都是同一个地址,后者不常用.
函数名`fun`与`*fun`打印出来的也都是同一个指针,后者不常用.

### 指向类对象的成员函数的指针

#### 定义

`成员函数返回类型(类名称::*指针变量名)(形参表)`

#### 赋值 

`指针变量名=&类名称::函数名`

这里之所以要加`&`,可以理解为是为了抵消使用时前面加的`*`
所赋值的函数必须时`public`

#### 使用

`(对象名.*指针变量名)(实参表)`

前面加`*`是为了与其他普通成员区分开来

### 高维字符数组与字符指针数组

`char a[3][10]`本质上是二维数组

`char *s[3]`则是一个指针数组,里面的每个指针可以再对应一个一维的字符数组,也可以是一个无名字符串,如果对于存储的字符串没有改变的需求的话,推荐用第二种.如果用第二种的话应该要使用`const char *s[3]`

二维字符数组相比于一维指针数组的优势有：

1. 与无名字符串常量分占不同空间
2. 字符串的值可以修改

缺点有：

1. 有空间浪费
2. 若要交换元素，则需整体移动元素

一维数组指针相对于二维字符数组的优点有：

1. 节约空间
2. 交换时只需交换指针即可，效率高

缺点有：

1. 如果指针指向无名字符串常量，则无法改变字符串的值

### 指向指针的指针

#### 定义 

`数据类型**指针变量名`

### const 指针

为了避免通过指针来改变其所指变量的值,我们可以将指针的基类型前面或后面加上 `const`,使得指针所指的变量变为只读.

通常的变量既能读,也能写,可以赋值给只读的`const`变量,而反方向则不行,不能赋予另一个变量以自己没有的权限.实参与形参之间的赋值也遵循这种规律.

### 常指针

形式为`数据类型*const指针变量名`，特点为：

1. 可以通过执政修改变量的值，即有读写权限
2. 必须在定义时初始化，不能再指向其他同类型的变量
3. 适用于希望指针始终指向某个变量的情况

由于特点一，如果常指针的基类型不为常变量的话，它不能指向常变量。

指向常量的常指针形式为`const 数据类型 *const 指针变量名`，特点为

1. 只有读的权限
2. 必须在定义时初始化
3. 适用于即希望始终指向固定变量，又希望不能通过执政修改变量值的情况。

### void指针

含义为指向空类型的指针变量，其特点为：

1. 不能直接通过`void`指针访问数据（不知道基类型），必须强制转换为某种确定的数据类型后才能访问。
2. 非 `void`型的指针可以直接赋值给 `void`类型，`void`类型赋值给非`void`类型时必须强制转换。


### 空指针`NULL`

空指针允许有空值 `NULL`，表示不指向任何变量。系统的字符串操作函数若传入参数为 `NULL`则会报错。

### 引用

数组的引用`char(&s1)[list.length]`能够保留数组长度这一信息，与指针不一样。
但是这样的使用固定住了数组的长度，不太实用。
当然通过某些途径可以让数组长度可变。
与指针不同，引用数组时必须要大小一致。同时不能将一个指向数组的指针传给数组的引用，因为指针已经失去了长度信息。

需要注意的是，引用并不能完全替代指针。

定义结构体时，成员类型不能是其本身，但是可以是指向自己的指针，因为指针大小已知。
