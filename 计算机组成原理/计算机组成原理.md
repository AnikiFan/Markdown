# 计算机组成原理

## 运算方法和运算部件

### 数制

常用的数制有：十进制，二进制，八进制和十六进制。

常用的转换方式有：

1. 十进制转二进制：整数部分采用逆向取余数的方式，小数部分则是每次乘2按顺序取个位。计算小数部分时，可能会出现无限循环，假设以及按照该方法取出了k位小数，那么这k位就已经确定下来了，且是准确的，误差只可能发生在k+1位小数及以后，所以误差小于$2^{-k}$。
2. 二进制转十进制：采用加权展开的方式
3. 二进制与八进制或十六进制之间的转换：一位八进制数对应3位二进制数；一位十六进制数对应4位二进制数。在转换时，按需在前端或末端添加0，转换结束后删去前端或后端的0。

### 编码

在计算机中存储的数据对应着某个数，我们将这个数成为“真值”，在这里我们规定真值必须要有正负之分。特别地，我们要考虑“正零”和“负零”。

#### 十进制数的编码与运算

计算机中的数据都以二进制存储，只由01组成。所以如果想要在计算机中直接存储十进制数，需要以编码的方式，也就是用特定的二进制组合来表示一个十进制数。

表示方案主要可以分为有权码和无权码

##### 有权码

在这类方案中，每个位置上的01值都对应这十进制中的某个值，称为权重，将每一位1所对应的权重相加，便可以得到整个组合所代表的十进制数。

常用的有权码是BCD码，也称8421码，因为该码共4位，从左到右对应的权重为8，4，2，1。也就是该编码方式和十进制数转换为2进制后的表示方式一致。

但是这种编码方式只考虑了0-9，使得当两个编码进行相加时，如果某位上的和大于9，则需要在该位上在加上6，也就是BCD码0110，以产生正确的进位。

##### 无权码

余3码是在0-9的4位二进制表示的基础上加上0011，即3，得到的编码。在使用余3码进行加法运算时，如果没有产生进位，则需要在该位减去0011，使得该位
符合余3码的规则（+3+3-3=+3）；如果进位，则需要再加上0011，使得该位符合余3码的规则（+3+3-6+3=+3，进位扣除了6）.

格雷码的特点是任何两个响铃编码只有1个二进制位不同。

### 计算机中的二进制数据表示及运算

在机器中并没有正负号，只能用01来表示正负，不同的表示方法产生了不同的编码方式。我们称计算机中用01串来表示的带符号的二进制数为”机器数“。
对于同一个真值$X$，它所对应的机器数可以由原码，补码或反码来表示。

要注意的是，对于任意一个真值，它的机器数是由表示实际在计算机中存储的编码，以及编码规则所决定的，所以机器数可能会和真值有偏差。真值的取值范围是实数，而机器数的取值范围则是特定编码格式所能表示的有限多个数。

因此，虽然机器数仍是个二进制——有小数点、由01组成，但是我们其中的01与其代表数值，更多的是一种符号含义，例如，我们规定第一位是符号位，为1代表真值为正，否则为负。我们只是在转换和运算时将其视为二进制数值。

接下来定义的各种编码，实际上是定义了两个函数$f,g$：

给定真值 $X$，由 $f$转换为能在计算机中直接存储和运算的二进制数，这个二进制数就是机器数，$g$则负责将这个机器数转换为实际在计算机中存储的01串（例如去除小数点等）。

二进制数可以分为整数，定点小数（小数点前只有1位的小数），和浮点小数（小数点前位数不定的小数）。这几种类型有各自的编码，即使共用一套编码规则，
具体的转换函数也略有差别。

#### 定点小数编码

在定点小数编码中，机器数对应的机器数也是一个小数，且规定小数点前为符号位。

\[
[X]_{原} = \begin{cases}
X&，X为正\\
1-X&，X为负\\
\end{cases}    
\]
\[
[X]_{补} = \begin{cases}
X&，X为正\\
2+X \mod 2&，X为负\\
\end{cases}    
\]
$[Y]_{补}$形成$[-Y]_{补}$的方法是从左到右依次取反，直到最后一个1为止（不包括对最后一个1取反）。
\[
[X]_{反} = \begin{cases}
X&，X为正\\
2-2^{-n}+X &，X为负\\
\end{cases}    
\]
对于正真值，三种编码方式得到的机器数相同。对于负真值，首先我们容易得到原码的表示方式；我们在原码的基础上保持符号位不变，数值位取反即可得到反码；保持符号位不变，数值部分从左到右依次取反，直到最后一个1为止（不包括），即可得到补码。

原码和补码在运算时遵循模2，而反码运算时遵循模 $2-2^n$，其中 $n$为精度，也就是说，当最高位产生进位时，要在最低位加1.
反码之所以遵循模$2-2^n$，是因为在反码中，正零和负零分别为$0.00\cdots0,1.11\cdots1$，两者正好紧挨着，如果得到的结果正好是负零，那么习惯上我们把它调整为正零，相当于进行了模$2-2^n$操作，如果得到的结果最高位需要进位，那么由于即跨过了负零又跨过了正零，所以需要通过加$2^n$来补偿，这一点也可以通过模$2-2^n$操作来实现。

如果机器数数值部分有n位，则原码，补码，反码能表达的正真值范围均为 $[0,1-2^n]$。对于负真值范围，原码和反码为$[-(1-2^n),0]$，补码则是 $[-1,0]$。

这里说的运算的结果都是一种编码，例如原码和原码的运算结果是一个原码，需要经过转换才能得到真值，运算中的进位规则和正常的运算一致而已

#### 整数编码

对于有着 $n$位数值的真值，
\[
[X]_{原} = \begin{cases}
X&，X为正\\
2^n-X&，X为负\\
\end{cases}    
\]
\[
[X]_{补} = \begin{cases}
X&，X为正\\
2^{n+1}+X&，X为负\\
\end{cases}    
\]
\[
[X]_{反} = \begin{cases}
X&，X为正\\
2^{n+1}-1+X &，X为负\\
\end{cases}    
\]

#### 浮点数编码

浮点数编码中使用了一种特别的整数编码——移码，只需把补码的符号码取反即可得到。因此，当移码全为0时，其真值为最小负值。移码进行加减法运算时，需要对结果的符号为取反。

有
\[[X\pm Y]_{移}=[X]_{移}+[\pm Y]_{补}\]

#### 乘法

|方法|部分积|乘数|被乘数|符号|补充|
|---|---|---|---|---|---|
|原码一位乘法|双符号位|无符号位|计算部分和时视为正数，也就是符号位为00|最后根据被乘数和乘数的符号决定||
|补码一位乘法|双符号位，右移时为算数右移，也就是补符号位|无符号位，数值部分和对应补码相同|转换为补码形式，包括符号位！|根据竖式计算结果直接得出|最后根据Y的符号进行调整后，不移位|
|布斯算法|双符号位，算数右移|使用一位符号位，考虑正负！并在末尾添加一个零|补码形式|根据符号直接得出|最后一次不移位，也就是存放在乘数部分的乘积低位位数最多只有乘数的位数|

乘法只有当两个最小负数相乘时会溢出，例如-1乘-1

#### 除法

|方法|被除数或余数|除数|余数|商|符号|
|---|---|---|---|---|---|
|不恢复余数法|双符号位，左移补0，绝对值原码形式|补码形式|如果最后一次商为0，则不左移并加上$[Y]_补$|从上到下，第一位为符号位，但是实际的符号直接根据除数和被除数的符号决定|直接决定|

当除数的绝对值小于被除数时，会产生溢出。

#### 浮点数

这里讨论的浮点数如果没有特别说明的话，不遵循IEEE754。

十进制数转换为浮点数时

1. 将十进制写为$0.x\cdots x\times D^d$的形式，其中 $D$为底，常取2，8或16
2. 将阶码$d$转换为要求的编码，注意，始终是01串
3. 将尾数$0.x\cdots x$转换为要求的编码，如果位数过长，则按照规定进行舍入

浮点数进行加减法时：

1. 通过减法比较两个阶码的大小。两个浮点数的编码格式应该相同，这里比较的本质上是阶码真值的大小关系，也就是 
\[X_{阶码}-Y_{阶码}\]
由于当两个真值的编码格式相同时，我们可以直接通过编码的运算结果——相同编码格式的一个编码，来得到实际真值的运算结果。实际上，我们这里便是通过编码的运算结果，以及那个编码的具体规则来判断那个阶码的真值更大。
2. 增加较小的阶码，同时右移对应的尾数，使得真值不发生变化（尽管可能会因为移位导致末尾被舍弃）
3. 尾数进行加减运算，运用双符号位
4. 调整尾数，使得双符号位相同，且与数值最高位不同。同时对应调整阶码
5. 舍入，调整时可能会导致还需要再次进行第4步，不断进行，直到不需要为止
6. 检查阶码是否溢出，在上述各步的过程中也要检查，如果出现溢出，则停止运算

其中，阶码常用移码来编码（移码只能编码整数），遵循以下运算规则：
\[[X\pm Y]_{移}=[X]_{移}\pm[Y]_{补}\]
使用单符号位时，移码与补码的转换只需要对符号位取反。

当使用双符号位时，第一位符号位正常时始终为0，第二位与使用单符号位时保持一致。当第一位变为1时，说明产生溢出，此时如果第二位为0，则表示上溢，否则为下溢。

阶码之间运算时，转化为阶码和补码之间的运算。此时如果阶码为负数，则双符号位为01，如果补码为负数，则双符号位为11。只要运算完后最左侧符号位为0便没有溢出，即使该位产生了进位

当基数为8或16时，尾数必须3位或4位一移，同时第四步的标准变为只需数值部分前3、4位中有一位和符号位不同即可。

### 校验码

#### 码距

为了实现校验功能，势必要有一部分信息传递能力要用于存储用于判断是否发生错误的信息。也就是说，有一些编码组合是非法的。我们定义任意两个合法的编码的二进制差异的位数的最小值为码距。当出错的位数小于码距时才有可能被检测出来，若大于等于码距，则出错的码可能会变为一个合法的码，但这实际上仍是一个错误。

#### 奇偶校验码

奇偶校验码的码距为2，只能发现奇数位错误，且无法进行定位。

实现的方式是在一段数据后加一个二进制位来使得整个01串满足特定的奇偶性。对于奇校验，补充的那一位二进制会使得1的个数为奇数，所以可以通过判断已有数据中是否有偶数个1来判断该位为1还是0。类似地有偶校验。

当我们接收到奇偶校验码后，可以根据1的个数以及其是奇校验还是偶校验来判断错误是否发生。

#### 海明码

海明码设有$r$位校验位，假设有$k$位数据，如果想要能够纠正数据的一位错，那么这$r$位校验位所能够表示的$2^r$个信息需要包含$k$位各位是否有错，$r$位校验码自身是否有错，以及是否没有错误这$k+r+1$个信息，所以需要满足关系式
\[2^r\geq k+r+1\]

如果想要能够自动校正一位错，并发现两位错，那么在$r$位校验位中，有一位负责表示出错个数的奇偶性，其余位数中的信息仍需包含这$k+r$位的各位是否有错。从而有
\[2^{r-1}\geq k+r\]