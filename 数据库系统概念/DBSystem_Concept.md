# Database System Concept

## Relational Database Design Optimization

### 数据库优化目标

1. 避免冗余数据
2. 能够表示出属性之间存在着的关系
3. 有助于检验一致性约束

### 函数依赖

函数依赖实际上就是说一组属性到另一组属性之间存在一个函数关系（两组属性不一定互斥）。这一定义实际上是用于检验的，而并非用于判断的。也就是说，两组属性之间是否存在函数依赖通常是根据现实意义来直接判断出来的。

显然，当自变量对应的属性减少或因变量对应的属性增多时，函数依赖增强了，反之则减弱了。

当函数依赖$\alpha \rightarrow \beta$成立，且$\alpha$无法再缩小时，则称该$\beta$完全依赖于$\alpha$，否则称为部分依赖。

### 分解

一个大关系可以分解为若干个小关系，必要时再将他们连接起来，这些小关系的属性之间不必互斥。

如果采用自然连接后所得的关系和原关系完全相同，则称该分解为无损分解。

对于分解为两个关系的分解，如果得到的两个关系的属性的交集不为空时，该交集为至少为分解得到的一个关系的超码，则这个分解便是无损的。

对于分解为多个关系的分解，采用表格法来判断是否为无损分解。列为各个属性，行为分解得到的各个关系。一开始，将各个空格填上$a_{i,j}$，如果对于某个关系，给定函数依赖集在它上面的限制中的因变量中含有某属性，则将该位置改为$a_j$。然后遍历所给的函数依赖，如果某两行上的自变量对应着的属性相同，则将其因变量对应着的属性上的元素改为相同的，优先改为形如$a_i$的样式。遍历完所有函数依赖后，如果有一行上的元素都形如$a_i$，则说明该分解时无损分解。

### 函数依赖集

有三条公理可以用于从已知函数依赖中推导出新的函数依赖：

1. （自反律）$\beta\subseteq\alpha\Rightarrow\alpha\rightarrow\beta$
2. （增广律）$\alpha\rightarrow\beta\Rightarrow\gamma\alpha\rightarrow\gamma\beta$
3. （传递律）$\alpha\rightarrow\beta,\beta\rightarrow\gamma\Rightarrow\alpha\rightarrow\gamma$

可以证明，这具有Soundness and Completeness.

从一个函数依赖集$F$可以推导出来的所有函数依赖所组成的集合叫做原集合的闭包$F^{+}$。

只需要对于已经得到的函数依赖集中的每个函数依赖依次使用自反律和增广律，然后使用传递率，如此循环，知道无法得到新的函数依赖为止，我们便可以得到闭包。

### 属性集的闭包

对于一个指定的函数依赖集$\mathbf{\alpha}$，一个属性集的闭包$\mathbf{\alpha}^{+}$定义为可以用该函数依赖集推导出来的所有因变量所组成的集合。
\[\alpha\rightarrow\beta\in F^{+}\Leftrightarrow\beta\in\mathbf{\alpha}^{+}\]
想要求出一个属性集的闭包，只需维护一个属性集，其中的属性是可以依据所给$F$（而非$F^{+}$）直接得到的因变量，一开始包含$\mathbf{\alpha}$，随着不断更新而扩大，最终确定下来的集合便是所求的闭包。

### 正则覆盖

对于一个函数依赖集，我们称与之等价的、且无冗余属性和函数依赖的函数依赖集为它的正则覆盖。

对于一个函数依赖$\alpha\rightarrow\beta$，如果我们从$\alpha$中删去一个属性，我们得到的是一个更强的函数依赖，因此我们需要证明这实际上是可以从已知函数依赖集中推导出来的；如果我们删去$\beta$，我们得到的是一个更弱的函数依赖，因此我们需要证明采用这个函数依赖时，仍然可以推导出当前的函数依赖集

想要计算一个函数依赖集的闭包，我们首先需要将形如$\mathbf{\alpha}\rightarrow\mathbf{\beta_i}$的函数依赖合并为$\mathbf{\alpha}\rightarrow\prod_i\mathbf{\beta_i}$，然后验证是否能够进行上述化简，如此往复，知道确定为止，这样得到的集合便是闭包。

### 候选码

给定函数依赖集，和一个关系，可以将该关系中的各个属性按照是否只作为自变量、只作为因变量、既作为自变量又作为因变量、既不作为自变量又不作为因变量划分为4类，分别记为L、R、LR、N，将$L\cup N$记为$X$，如果$X$能够作为超码，那么$X$就是唯一的候选码，否则，遍历$LR$的一元子集，将其和$X$作并后判断是否为超码，如果是则记为一个候选码，如果在这一轮中没有找到任何一个候选码，则再次继续遍历$X$的二元子集，以此类推，知道找到候选码为止。

## B+-树

对于一个B+-树，有一个参数$n$是确定的。

### 结点

|第一个指针域|第一个值域|第二个指针域|$\cdots$|第$i$个指针域|第$i$个值域|第$i+1$个指针域|$\cdots$|第$n-1$给值域|第$n$个指针域|
|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|----------|---------|
|$P_1$|$K_1$|$P_2$|$\cdots$|$P_i$|$K_i$|$P_{i+1}$|$\cdots$|K_{n-1}|$P_n$|
|$<K_1$||$\leq K_1$|$\cdots$|$<K_i$||$\leq K_{i}$|$\cdots$||下一个兄弟结点|

#### 非叶子结点

指针域中存储的是指向结点的指针。

若不是根节点，则需要有$\lceil n/2\rceil$到$n$个孩子，即有$\lceil n/2\rceil$到$n$个非空指针域。

若是根节点，则需要有$2$到$n$个孩子，即有$2$到$n$个非空指针域。

#### 叶子结点

指针域中存储的是指向其右侧值域对应的文件记录（在磁盘中的位置）的指针。结点最右侧的指针指向的是兄弟结点。

要求至少有$\lceil (n-1)/2\rceil$个非空值域。

### 查询操作

#### 单值查询

从根节点出发，要一直下降至对于的叶子结点中，然后载该叶子结点中进行遍历比较。

为了下降到正确的孩子结点中，由于$P_i$，$P_{i+1}$指向的左右两个孩子结点中存储的值以$K_i$作为分界，所以只需要将查询值与$K_i$进行比较即可。从第一个值域开始比较，若小于，则沿左侧的指针下降，否则继续与下一个值域进行比较，查看是否有机会沿右侧指针下降，极端情况是所有值域都小于待查询值，此时将指针设为最右侧的指针域。

下降到叶子结点后，对其进行遍历，若没有找到，则返回空指针。

### 更新操作

#### 插入

当插入一个值时，首先要通过单值查询操作获取到应该插入的叶子结点。如果该叶子没有满，则直接按照顺序插入即可。否则，插入前应该有$n-1$个值域，加上待插入的值，便有$n$个值域，为此，需要分为两个叶子结点，前$\lceil n/2\rceil$个值域留在原来的叶子结点中，后续值域分给新的叶子结点。

此时，需要在原先叶子结点的父结点中增加一个值域和一个指针域（指针域在值域的右侧），分别是新的叶子结点中的第一个值以及指向新的叶子结点的指针。如果不会产生溢出，则直接插入即可。否则，先将新增值域和指针域按照顺序插入。然后进行拆分，将前$\lceil (n+1)/2\rceil$(可以看到，分配给左边的，即保留在原节点的总是大于分配给右边的)个指针域以及夹在其中的结点保留在原结点中，而剩余的指针域以及夹在其中的值域转移到新增的兄弟结点中。此时，仍有一个值域没有被安放，它随同指向新增结点的指针一同插入到原结点的父节点中（指针域在值域的右侧），形成递归。

#### 删除

当删除一个值时，若它是根结点且删除后只有一个孩子，则直接把它的孩子结点作为新的根节点。

否则。如果被删除的叶子结点中的值/指针过少，则尝试和左兄弟结点进行合并。如果可以进行，即左兄弟结点仍有空间，则将它们合并，左兄弟的指向右兄弟的指针替换为右兄弟对应位置的指针，并将如果不是叶结点，还要添加父节点中夹在指向兄弟结点指针中间的值域。此时，还需要删除父结点中夹在指向两兄弟结点的指针中间的值，同时还要删除被合并的结点，即右兄弟结点的指针。此时进行递归，且如果删除操作不是对于叶子结点，则无需更新指向兄弟结点的指针（实际上也不存在）。

如果不可以进行，则说明左兄弟结点已满。因为删除前是满足约束的，意味着只需要增加一项便可以重新满足约束，从而思想是从左兄弟结点中“借”一个值-指针对。只需要直接将左兄弟的最后一对移动到右兄弟的起始就行了，同时还要修改父结点中的一个值域（无需修改指针域），即指向右兄弟结点的指针域对应的值域，需要改为移动的值域。要注意的是，对于叶子结点，最后一个值域-指针域对是倒数第二、三个非空的域，倒数第一个是指向兄弟结点的指针域。而对于非叶子结点而言，便是最后两个非空域。对于非叶子结点，操作复杂一些，左兄弟结点的最后一个值域移动到父结点中的指向兄弟结点的指针中间的值域，而原先在该值域的值和左兄弟结点的最后一个指针域移动到右兄弟结点的开端。

上述操作中，不一定是要选择左兄弟结点来进行调整，原则是要让指向两个兄弟结点的指针在同一父节点中。